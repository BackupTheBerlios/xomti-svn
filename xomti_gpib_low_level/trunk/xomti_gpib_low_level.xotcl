# automatically generated from XOTclIDE
package provide fidev_gpib_low_level 99991231.1

@ tclproc ::Xomti_GPIB_Board::scruteSRQ_periodic idemeta struct fidev_gpib_low_level GPIB_Board
proc ::Xomti_GPIB_Board::scruteSRQ_periodic {board delai} {
    ::Xomti_GPIB_Board::scruteSRQ $board
    after $delai ::Xomti_GPIB_Board::scruteSRQ_periodic $board $delai
}
@ tclproc ::Xomti_GPIB_Board::iniSRQ idemeta struct fidev_gpib_low_level GPIB_Board
proc ::Xomti_GPIB_Board::iniSRQ board {
    ::Xomti_GPIB_Board::scruteSRQ_periodic $board 20
}
@ Class Xomti_GPIB {
description {    14 janvier 2002 (FP) gpib.1.1.tcl  Modif prefix dans "GPIB::newGPIB"
    8 février 2002 (FP) gpib.1.2.tcl  ajout "gpibCopyName"
    29 avril 2003 (FP) ajout du namespace GPIB
2005-01-21 (FP) passage en xotcl}
}
Class Xomti_GPIB
@ ::Xomti_GPIB idemeta categories {mettre_ailleurs level0 level1 private ui level2}
@ ::Xomti_GPIB idemeta categoriesMethods {{Write copyGPIB deviceLevel} {Command Command2 renOn renOff} {IFC get mla mta unt unl sdc spe spd ren0 ren1} {board_get init} {lowLevel traceOn traceOff readByte readLine ui ui_renOff ui_renOn device_level_ui gpib_lowlev_ui low_level_ui} {rd wrt rdBin serialPoll}}
@ ::Xomti_GPIB idemeta component fidev_gpib_low_level
Xomti_GPIB instproc Command comm {
    ::Xomti_GPIB_Board::1cmd [my board_get] [::Xomti_GPIB::Commands byte_get $comm]
}
Xomti_GPIB instproc Command2 {comm i} {
    ::Xomti_GPIB_Board::1cmd [my board_get] [expr {[::Xomti_GPIB::Commands byte_get $comm] + $i}]
}
Xomti_GPIB instproc IFC {} {
    ::Xomti_GPIB_Board::sic [my board_get]
}
Xomti_GPIB instproc Write {} {
    set ecrit [.gpib.text_toGPIB get sel.first sel.last]
    ::Xomti_GPIB_Board::wrt [my board_get] $ecrit
}
Xomti_GPIB instproc address_get {} {
    return [my set address]
}
Xomti_GPIB instproc board_get {} {
    return [my set board]
}
Xomti_GPIB instproc copyGPIB {oldName newName} {
    upvar #0 $oldName oldArr
    upvar #0 $newName newArr
    global gpibNames
    
    set newArr(gpibBoard) $oldArr(gpibBoard)
    set newArr(gpibAddr) $oldArr(gpibAddr)
    set newArr(classe) $oldArr(classe)
    
    set gpibNames($oldArr(gpibBoard),$oldArr(gpibAddr)) $newName
    proc $newName [info args $oldName] [info body $oldName]

    namespace export $newName
    if {[catch {namespace eval :: "namespace import GPIB::$newName"} err]} {
	puts stderr $err
    }
}
Xomti_GPIB instproc deviceLevel {} {
    grid remove .gpib.frame_low_level
    grid .gpib.frame_device_level -in .gpib -row 3 -column 1
    .gpib.button_device_level configure -relief sunken
    .gpib.button_low_level configure -relief raised
}
Xomti_GPIB instproc device_level_ui {root args} {
# interface generated by SpecTcl version 1.0 from /home/fab/Tcl/gpib/device_level.ui
#   root     is the parent window for this user interface

	# this treats "." as a special case

	if {$root == "."} {
	    set base ""
	} else {
	    set base $root
	}
    
	button $base.button#3  -text dev#20


	# Geometry management

	grid $base.button#3 -in $root	-row 1 -column 1 

	# Resize behavior management

	grid rowconfigure $root 1 -weight 0 -minsize 30
	grid columnconfigure $root 1 -weight 0 -minsize 30
# additional interface code
# end additional interface code

}
Xomti_GPIB instproc get {} {
    my Command GET
}
Xomti_GPIB instproc gpib_lowlev_ui {root args} {
# interface generated by SpecTcl version 1.0 from /home/fab/Tcl/gpib/main.ui
#   root     is the parent window for this user interface
	# this treats "." as a special case

	if {$root == "."} {
	    set base ""
	} else {
	    set base $root
	}
    
	frame $base.frame#9

	frame $base.frame_globals

	frame $base.frame_UnaddressedGeneralCommands  -borderwidth 8

	label $base.label#1  -text {Commandes GPIB}

	button $base.button_GPIB_LLO  -command [list [self] Command LLO] -text LLO

	button $base.button_REN_On  -command [list [self] renOn]  -text {REN On}

	button $base.button_REN_Off  -command [list [self] renOff]  -text {REN Off}

	label $base.label_SRQ  -text {no SRQ}  -textvariable variable_SRQ

	button $base.button#43  -command [list [self] Write]  -padx 0  -text Write  -width 10

	text $base.text_toGPIB  -height 1  -width 1

	button $base.button_read_Line  -command [list [self] readLine]  -padx 0  -text {read Line}  -width 10

	text $base.text_fromGPIB  -height 1  -width 1

	button $base.button_low_level  -command [list [self] lowLevel]  -text {low level}

	button $base.button_device_level  -command [list [self] deviceLevel]  -text {device level}

	button $base.button_trace_On  -command [list [self] traceOn] -text {trace On}

	button $base.button_trace_Off  -command [list [self] traceOff] -text {trace Off}

	button $base.button#49  -command "destroy $base"  -text Close


	# Geometry management

	grid $base.frame#9 -in $root	-row 4 -column 1 
	grid $base.frame_globals -in $root	-row 5 -column 1 
	grid $base.frame_UnaddressedGeneralCommands -in $root	-row 2 -column 1 
	grid $base.label#1 -in $root	-row 1 -column 1 
	grid $base.button_GPIB_LLO -in $base.frame_UnaddressedGeneralCommands	-row 1 -column 1 
	grid $base.button_REN_On -in $base.frame_UnaddressedGeneralCommands	-row 1 -column 2 
	grid $base.button_REN_Off -in $base.frame_UnaddressedGeneralCommands	-row 1 -column 3 
	grid $base.label_SRQ -in $base.frame_UnaddressedGeneralCommands	-row 1 -column 4 
	grid $base.button#43 -in $base.frame#9	-row 1 -column 1   -sticky n
	grid $base.text_toGPIB -in $base.frame#9	-row 1 -column 2   -sticky nesw
	grid $base.button_read_Line -in $base.frame#9	-row 2 -column 1   -sticky n
	grid $base.text_fromGPIB -in $base.frame#9	-row 2 -column 2   -sticky nesw
	grid $base.button_low_level -in $base.frame_globals	-row 1 -column 1 
	grid $base.button_device_level -in $base.frame_globals	-row 1 -column 2 
	grid $base.button_trace_On -in $base.frame_globals	-row 1 -column 4 
	grid $base.button_trace_Off -in $base.frame_globals	-row 1 -column 5 
	grid $base.button#49 -in $base.frame_globals	-row 1 -column 6 

	# Resize behavior management

	grid rowconfigure $base.frame_globals 1 -weight 0 -minsize 30
	grid columnconfigure $base.frame_globals 1 -weight 0 -minsize 30
	grid columnconfigure $base.frame_globals 2 -weight 0 -minsize 30
	grid columnconfigure $base.frame_globals 3 -weight 0 -minsize 30
	grid columnconfigure $base.frame_globals 4 -weight 0 -minsize 30
	grid columnconfigure $base.frame_globals 5 -weight 0 -minsize 30
	grid columnconfigure $base.frame_globals 6 -weight 0 -minsize 30

	grid rowconfigure $root 1 -weight 0 -minsize 30
	grid rowconfigure $root 2 -weight 0 -minsize 30
	grid rowconfigure $root 3 -weight 0 -minsize 30
	grid rowconfigure $root 4 -weight 0 -minsize 30
	grid rowconfigure $root 5 -weight 0 -minsize 30
	grid columnconfigure $root 1 -weight 0 -minsize 30

	grid rowconfigure $base.frame_UnaddressedGeneralCommands 1 -weight 0 -minsize 30
	grid columnconfigure $base.frame_UnaddressedGeneralCommands 1 -weight 0 -minsize 30
	grid columnconfigure $base.frame_UnaddressedGeneralCommands 2 -weight 0 -minsize 30
	grid columnconfigure $base.frame_UnaddressedGeneralCommands 3 -weight 0 -minsize 30
	grid columnconfigure $base.frame_UnaddressedGeneralCommands 4 -weight 0 -minsize 30

	grid rowconfigure $base.frame#9 1 -weight 0 -minsize 55
	grid rowconfigure $base.frame#9 2 -weight 1 -minsize 80
	grid columnconfigure $base.frame#9 1 -weight 0 -minsize 30
	grid columnconfigure $base.frame#9 2 -weight 1 -minsize 493
# additional interface code
# end additional interface code

}
Xomti_GPIB instproc init board_object {

    if {[Xomti_GPIB info instances] == {}} {
        Xomti_GPIB init
    }

    set MACHTYPE $::tcl_platform(os)
    my instvar board
    set board_name [$board_object name_get]

    # initialisation de la carte
    if {$MACHTYPE == "Linux"} {
	#        ::Xomti_GPIB_Board::find "voltmeter" ;# bidon pour initialiser la carte, à revoir
	my set board [::Xomti_GPIB_Board::find $board_name]
	#if {[::Xomti_GPIB_Board::isMaster $board]} {
	#    puts "Opened $board_name as master"
	#} else {
	#    puts "device $board_name is not set as master"
	#    exit
	#}
	::Xomti_GPIB_Board::onl $board 1
	::Xomti_GPIB_Board::sic $board
	::Xomti_GPIB_Board::sre $board 1
	
    } else {
	my set board [::Xomti_GPIB_Board::find $board_name]
    }

    my set address 0 ;# standard ?
    
    #    [jniNewObject ()V l2m/fico/GPIB/Board]
    $board_object standardInit $board
    

# configuration de depart
    my renOff
    my traceOff
    
# prise en compte du SRQ au niveau de la carte

    global SRQstatus
    
    ::Xomti_GPIB_Board::iniSRQ $board
    trace variable SRQstatus w {Xomti_GPIB srqIsWritten}
    
}
Xomti_GPIB instproc lowLevel {} {
    grid remove .gpib.frame_device_level
    grid .gpib.frame_low_level -in .gpib -row 3 -column 1
    .gpib.button_device_level configure -relief raised
    .gpib.button_low_level configure -relief sunken
}
Xomti_GPIB instproc low_level_ui {root args} {
# interface generated by SpecTcl version 1.0 from /home/fab/Tcl/gpib/low_level.ui
#   root     is the parent window for this user interface
	# this treats "." as a special case

	if {$root == "."} {
	    set base ""
	} else {
	    set base $root
	}
    
	frame $base.frame#1

	frame $base.frame#9

	frame $base.frame#10

	frame $base.frame_MLA_MTA

	button $base.button_IFC  -command [list [self] IFC] -text IFC

	button $base.button_DCL  -command [list [self] Command DCL] -text DCL

	button $base.button_SPE  -command [list [self] Command SPE]  -text SPE

	button $base.button_SPD  -command [list [self] Command SPD]  -text SPD

	button $base.button_UNL  -command [list [self] Command UNL] -text UNL

	button $base.button_UNT  -command [list [self] Command UNT]  -text UNT

	button $base.button_GET  -command [list [self] Command GET]  -text GET

	button $base.button_GTL  -command [list [self] Command GTL]  -text GTL

	button $base.button_SDC  -command [list [self] Command SDC]  -text SDC

	button $base.button_TCT  -command [list [self] Command TCT]  -text TCT

	button $base.button_readByte  -command [list [self] readByte]  -text {read Byte}

	button $base.button_rescan_ll  -command [list [self] rescanDevices_lowLevel]  -text {rescan Devices}

	button $base.button#38  -command [list [self] Command2 MTA 0]  -text {MTA gpib0}

	button $base.button#39  -command [list [self] Command2 MLA 0]  -text {MLA gpib0}


	# Geometry management

	grid $base.frame#1 -in $root	-row 1 -column 1 
	grid $base.frame#9 -in $base.frame#1	-row 1 -column 1 
	grid $base.frame#10 -in $base.frame#9	-row 2 -column 1   -columnspan 10  -sticky w
	grid $base.frame_MLA_MTA -in $base.frame#10	-row 1 -column 2 
	grid $base.button_IFC -in $base.frame#9	-row 1 -column 1 
	grid $base.button_DCL -in $base.frame#9	-row 1 -column 2 
	grid $base.button_SPE -in $base.frame#9	-row 1 -column 3 
	grid $base.button_SPD -in $base.frame#9	-row 1 -column 4 
	grid $base.button_UNL -in $base.frame#9	-row 1 -column 5 
	grid $base.button_UNT -in $base.frame#9	-row 1 -column 6 
	grid $base.button_GET -in $base.frame#9	-row 1 -column 7 
	grid $base.button_GTL -in $base.frame#9	-row 1 -column 8 
	grid $base.button_SDC -in $base.frame#9	-row 1 -column 9 
	grid $base.button_TCT -in $base.frame#9	-row 1 -column 10 
	grid $base.button_readByte -in $base.frame#10	-row 1 -column 1 
	grid $base.button_rescan_ll -in $base.frame#10	-row 1 -column 3 
	grid $base.button#38 -in $base.frame_MLA_MTA	-row 1 -column 1   -sticky w
	grid $base.button#39 -in $base.frame_MLA_MTA	-row 1 -column 2   -sticky e

	# Resize behavior management

	grid rowconfigure $base.frame_MLA_MTA 1 -weight 0 -minsize 30
	grid rowconfigure $base.frame_MLA_MTA 2 -weight 0 -minsize 30
	grid columnconfigure $base.frame_MLA_MTA 1 -weight 0 -minsize 30
	grid columnconfigure $base.frame_MLA_MTA 2 -weight 0 -minsize 30

	grid rowconfigure $root 1 -weight 1 -minsize 8
	grid columnconfigure $root 1 -weight 0 -minsize 453

	grid rowconfigure $base.frame#1 1 -weight 0 -minsize 30
	grid columnconfigure $base.frame#1 1 -weight 0 -minsize 30

	grid rowconfigure $base.frame#10 1 -weight 1 -minsize 30
	grid columnconfigure $base.frame#10 1 -weight 0 -minsize 30
	grid columnconfigure $base.frame#10 2 -weight 0 -minsize 234
	grid columnconfigure $base.frame#10 3 -weight 0 -minsize 137

	grid rowconfigure $base.frame#9 1 -weight 0 -minsize 30
	grid rowconfigure $base.frame#9 2 -weight 0 -minsize 30
	grid columnconfigure $base.frame#9 1 -weight 0 -minsize 30
	grid columnconfigure $base.frame#9 2 -weight 0 -minsize 30
	grid columnconfigure $base.frame#9 3 -weight 0 -minsize 30
	grid columnconfigure $base.frame#9 4 -weight 0 -minsize 30
	grid columnconfigure $base.frame#9 5 -weight 0 -minsize 30
	grid columnconfigure $base.frame#9 6 -weight 0 -minsize 30
	grid columnconfigure $base.frame#9 7 -weight 0 -minsize 30
	grid columnconfigure $base.frame#9 8 -weight 0 -minsize 30
	grid columnconfigure $base.frame#9 9 -weight 0 -minsize 30
	grid columnconfigure $base.frame#9 10 -weight 0 -minsize 30
# additional interface code
# end additional interface code

}
Xomti_GPIB instproc mla device {
    my Command2 MLA $device
}
Xomti_GPIB instproc mta device {
    my Command2 MTA $device
}
Xomti_GPIB instproc newGPIB {classe nom board addr} {
    upvar #0 $nom Arr
    global gpibNames
    set Arr(classe) $classe
    set Arr(gpibBoard) $board
    set Arr(gpibAddr) $addr
    set gpibNames($board,$addr) $nom
    
    proc $nom {commande args} {
	set name [lindex [info level [info level]] 0]
	upvar #0 $name Arr
	set board $Arr(gpibBoard)
	set addr $Arr(gpibAddr)
	if {$Arr(classe) == "smu"} {
	    package require smu
	    set prefix ::smu::
	    set firstarg "smuName"
	} elseif {$Arr(classe) == "2361"} {
	    package require 2361
	    set prefix ::2361::
	    set firstarg "2361Name"
	} elseif {$Arr(classe) == "egg7260"} {
	    package require egg7260
	    set prefix ::egg7260::
	    set firstarg "egg7260Name"
	} elseif {$Arr(classe) == "mm4005"} {
	    package require mm4005
	    set prefix ::mm4005::
	    set firstarg "mm4005Name"
	} elseif {$Arr(classe) == "a4156"} {
	    package require a4156
	    set prefix ::a4156::
	    set firstarg "a4156Name"
	} else {
	    set prefix ::$Arr(classe)::
	    set firstarg "$Arr(classe)Name"
	}
	if {[info commands $prefix$commande] != {}} {
	    eval $prefix$commande $name $args
	} else {
	    set goods {}
	    set lprefix [string length $prefix]
	    foreach c [info commands ${prefix}*] {
		if {[lindex [info args $c] 0] == $firstarg} {
		    lappend goods [string range $c $lprefix end]
		} else {
		    puts stderr "écarté (normal): $c"
		}
	    }
	    set goods [lsort $goods]
	    set message "l'option \"$commande\" est incorrecte: doit être [lindex $goods 0]"
	    foreach g [lrange $goods 1 [expr [llength $goods] - 2]] {
		append message ", $g"
	    }
	    if {[llength $goods] >= 2} {
		append message ", ou [lindex $goods end]"
	    }
	    error $message
	}
    }
    namespace export $nom
    if {[catch {namespace eval :: "namespace import GPIB::$nom"} err]} {
	puts stderr $err
    }
}
Xomti_GPIB instproc rd {device {len 512}} {
    ::Xomti_GPIB_Board::Command2 MTA $device
    ::Xomti_GPIB_Board::Command2 MLA [my board_get]
    set rep [::Xomti_GPIB_Board::rd [my board_get] $len]
    Xomti_GPIB_Board::unl ; Xomti_GPIB_Board::unt
    return $rep	;# retourne un ByteArray
}
Xomti_GPIB instproc rdBin {device {len 512}} {
    my mta [my board_get]
    my mla [my address_get]
    set rep [::Xomti_GPIB_Board::rdBin [my board_get] $len]
    my unl
    my unt
    return $rep	;# retourne une liste
}
Xomti_GPIB instproc readByte {} {
    set rep [::Xomti_GPIB_Board::rd [my board_get] 1]
    .gpib.text_fromGPIB insert end "$rep\n"
    .gpib.text_fromGPIB see end
}
Xomti_GPIB instproc readLine {} {
    set rep [::Xomti_GPIB_Board::rd [my board_get] 512]
    set len [string length $rep]
    if {$len == 0} {
        .gpib.text_fromGPIB insert end "0 caractère\n"
    } else {
        if {$len == 1} {
            .gpib.text_fromGPIB insert end "1 caractère : "
        } else {
            .gpib.text_fromGPIB insert end "$len caractères : "
        }
        .gpib.text_fromGPIB insert end "$rep\n"
    }
    .gpib.text_fromGPIB see end
}
Xomti_GPIB instproc ren0 {} {
    my renOff
}
Xomti_GPIB instproc ren1 {} {
    my renOn 
}
Xomti_GPIB instproc renOff {} {
    my ui_renOff
    ::Xomti_GPIB_Board::sre [my board_get] false
}
Xomti_GPIB instproc renOn {} {
    my ui_renOn
    ::Xomti_GPIB_Board::sre [my board_get] true
}
Xomti_GPIB instproc renameGPIB {oldName newName} {
    upvar #0 $oldName oldArr
    
    if {$newName == {}} {
        if {[info exists oldArr]} {
            unset oldArr
        }
        if {[info commands $oldName] != {}} {
            rename $oldName {}
        }
        return
    }
    
    upvar #0 $newName newArr
    global gpibNames
    
    set newArr(gpibBoard) $oldArr(gpibBoard)
    set newArr(gpibAddr) $oldArr(gpibAddr)
    set newArr(classe) $oldArr(classe)
    
    set gpibNames($oldArr(gpibBoard),$oldArr(gpibAddr)) $newName
    unset oldArr
    rename $oldName $newName ;# procédure associée
}
Xomti_GPIB instproc rescanBranches {} {
    set GPIB_Branches {}
    my renOff ;# pour eviter que le TC revienne au menu (BUG du TC ?)
    
    global MACHTYPE
    #if {$MACHTYPE == "Linux"} {
    #    puts stderr "::Xomti_GPIB_Board::ln à faire"
    #    return "0 15 16 17 18"
    #}
    for {set i 0} {$i<31} {incr i} {
        if {[::Xomti_GPIB_Board::ln [my board_get] $i 0]}  {
puts "$i est branché"
            lappend GPIB_Branches $i
        }
    }
    return $GPIB_Branches
}
Xomti_GPIB instproc rescanDevices_lowLevel {} {
    set GPIB_Branches [my rescanBranches]
    set zero [lsearch $GPIB_Branches 0]
    for {set i 1} {$i<31} {incr i} {
        destroy .gpib.button_MLA$i .gpib.button_MTA$i
    }
    if {$zero<0} {
        error "La carte n'est pas branchee en 0"
    }
    set ligne 1
    foreach d $GPIB_Branches {
        if {$d != "0"} {
            incr ligne
            button .gpib.button_MLA$d  -command [list [self] Command2 MLA $d]  -text "MLA dev$d"
            button .gpib.button_MTA$d  -command [list [self] Command2 MTA $d]  -text "MTA dev$d"
            grid .gpib.button_MLA$d -in .gpib.frame_low_level.frame_MLA_MTA  -row $ligne -column 2   -sticky e
            grid .gpib.button_MTA$d -in .gpib.frame_low_level.frame_MLA_MTA  -row $ligne -column 1   -sticky w
        }
    }
}
Xomti_GPIB instproc sdc {} {
    my Command SDC
}
Xomti_GPIB instproc serialPoll device {
    ;# renvoie la valeur du spb
    my unt
    my unl
    my spe
    my mta $device
    my mla [my address_get]
    set rep [::Xomti_GPIB_Board::rdBin [my board_get] 1]
    my unt
    my unl
    my spd
    return $rep
}
Xomti_GPIB instproc spd {} {
    my Command SPD
}
Xomti_GPIB instproc spe {} {
    my Command SPE
}
Xomti_GPIB instproc srqIsWritten {name1 name2 op} {
    upvar #0 $name1 srq
    global OLDSRQstatus SRQstatus variable_SRQ

    if {![info exists OLDSRQstatus] || $OLDSRQstatus != $SRQstatus} {
        # puts stderr "SRQ ----------------------> $SRQstatus"
        set OLDSRQstatus $SRQstatus
        if {$SRQstatus} {
            set variable_SRQ "SRQ !!!"
        } else {
            set variable_SRQ {}
        }
    }
}
Xomti_GPIB instproc srqWait {} {
    global variable_SRQ
    if {$variable_SRQ != {}} {
        puts stderr "direct return \"$variable_SRQ\""
        return $variable_SRQ
    }
    # puts stderr "idle ?"
    after idle {
        if {$variable_SRQ != {}} {
            puts stderr "SRQ Set in after"
            set variable_SRQ $variable_SRQ ;# pour tkwait
        }
    }
    # puts stderr "done, tkwait ?"
    tkwait variable variable_SRQ
    # puts stderr "done = $variable_SRQ"
    return $variable_SRQ
}
Xomti_GPIB instproc traceOff {} {
    if {[winfo exists .gpib]} {
        .gpib.button_trace_On configure -relief raised
        .gpib.button_trace_Off configure -relief sunken
    }
    ::Xomti_GPIB_Board::TRACE_ON false
}
Xomti_GPIB instproc traceOn {} {
    if {[winfo exists .gpib]} {
        .gpib.button_trace_On configure -relief sunken
        .gpib.button_trace_Off configure -relief raised
    }
    ::Xomti_GPIB_Board::TRACE_ON true
}
Xomti_GPIB instproc ui {} {
    if {[winfo exists .gpib]} {
        wm deiconify .gpib
        raise .gpib
    } else {
        toplevel .gpib
        my gpib_lowlev_ui .gpib
        frame .gpib.frame_low_level
        my low_level_ui .gpib.frame_low_level

        frame .gpib.frame_device_level
        my device_level_ui .gpib.frame_device_level
    }
    my traceOff
    my lowLevel
    # aide::nondocumente .gpib
}
Xomti_GPIB instproc ui_renOff {} {
    if {[winfo exists .gpib]} {
        .gpib.button_REN_On configure -relief raised
        .gpib.button_REN_Off configure -relief sunken
    }
}
Xomti_GPIB instproc ui_renOn {} {
    if {[winfo exists .gpib]} {
        .gpib.button_REN_On configure -relief sunken
        .gpib.button_REN_Off configure -relief raised
    }
}
Xomti_GPIB instproc unl {} {
    my Command UNL
}
Xomti_GPIB instproc unt {} {
    my Command UNT
}
Xomti_GPIB instproc wrt {device string} {
    my mta [my address_get]
    my mla $device
    ::Xomti_GPIB_Board::wrt [my board_get] $string
    my unl
    my unt
}
Xomti_GPIB proc init {} {
    Fidev_KeyByte create Xomti_GPIB::Commands {
        GTL 0x01
        SDC 0x04
        GET 0x08
        TCT 0x09
        LLO 0x11
        DCL 0x14
        SPE 0x18
        SPD 0x19
        MLA 0x20
        UNL 0x3f
        MTA 0x40
        UNT 0x5f        
    }
    Fidev_KeyByte create Xomti_GPIB::Lines {
        DAV  0
        NDAC 1
        NRFD 2
        IFC  3
        REN  4
        SRQ  5
        ATN  6
        EOI  7
    }
}
Xomti_GPIB proc test {} {
NI488_Driver create didi
didi build
didi cbuild

NI488_Board create bibi gpib0 didi
Xomti_GPIB create bobo bibi
bobo ui


}

