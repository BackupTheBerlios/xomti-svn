# automatically generated from XOTclIDE
# script require component {IDECore IDEBaseGUI}
@ Component IDEView {
description {There are the basis browser for XOTclIDE

1. Component Browser
2. Method Browser
3. Object Browser
4. Configuration Browser

and their subelements}
}
package provide IDEView 0.73
package require IDECore
package require IDEBaseGUI
Class IDE::AbstractClassView -superclass ::IDE::HListView
@ ::IDE::AbstractClassView idemeta component IDEView
IDE::AbstractClassView instproc browseChildren actual {
    if {[Object isclass $actual]} {
        IDE::HeritageBrowser newBrowserChild $actual
    } else {
        my upsMessage "$actual is not a class"
    }
}
IDE::AbstractClassView instproc browseHeritage actual {
    if {[Object isclass $actual]} {
        IDE::HeritageBrowser newBrowser $actual
    } else {
        my upsMessage "$actual is not a class"
    }
}
IDE::AbstractClassView instproc createInstance actual {
    if {[$actual istype Class]} {
        set obj [IDE::System createInstance $actual]
        if {$obj!=""} {$obj inspect}
    }
}
IDE::AbstractClassView instproc exportToFile actual {
    global tcl_platform
    my instvar vclass
    if {$tcl_platform(platform)=="windows"} {
        regsub -all :: $actual _ name
    } else {
        set name $actual
    }
    set file [IDE::Dialog getSaveFile $name.xotcl]
    if {$file==""} return
    set fh [open $file w]
    if {[$vclass istype IDE::ProcsGroup]} {
        set body [$vclass getBody]
    } else {
        set body [IDE::Component getObjectBody $actual]
    }
    puts -nonewline $fh $body
    close $fh
}
IDE::AbstractClassView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms addCommand2 {Heritage Browser} [list [self] dispatchWithSelected browseHeritage] isValidSelection
    $ms addCommand2 {Children Browser} [list [self] dispatchWithSelected browseChildren] isValidSelection
    $ms addCommand2 {Search References} [list [self] dispatchWithSelected searchUsage] isValidSelection
    $ms addCommand2 {Track This Class} [list [self] dispatchWithSelected trackClass] isValidSelection
    $ms addCommand2 {Create Instance} [list [self] dispatchWithSelected createInstance] isValidSelection
    $ms addCommand2 {Inspect All Instances} [list [self] dispatchWithSelected inspectAllInstances] isValidSelection
    $ms addCommand2 {Export To File} [list [self] dispatchWithSelected exportToFile] isValidSelection
    next
}
IDE::AbstractClassView instproc inspectAllInstances actual {
    if {[$actual istype Class]} {
        IDE::ObjectBrowser browseAllInstances $actual
    } elseif {[Object isobject $actual]} {
        $actual inspect
    }
}
IDE::AbstractClassView instproc searchUsage actual {
    if {[Object isclass $actual]} {
        IDE::MethodBrowser searchClassUsage $actual
    } else {
        my upsMessage "$actual is not a class"
    }
}
IDE::AbstractClassView instproc trackClass actual {
    if {[Object isclass $actual]} {
        $actual trackOn
    } else {
        IDE::Dialog error "I can track only classes"
    }
}
Class IDE::ArrayBrowser -superclass {::IDE::Browser ::IDE::GUICommands}  -parameter {vobject varray {atHead 1}}
@ ::IDE::ArrayBrowser idemeta categories {initialize private actions}
@ ::IDE::ArrayBrowser idemeta categoriesMethods {{getTitle getMenuStruct fillMenuStruct specificInit} dispatchWithKey {inspectAsObject removeKey addKey editSave initContents selectKey inspectAsObjectList}}
@ ::IDE::ArrayBrowser idemeta component IDEView
IDE::ArrayBrowser instproc addKey {} {
    my instvar varray
    set key [IDE::IDialogEntry getValue {Enter new key name}]
    if {$key==""} return
    my varAction set ${varray}($key) {}
    [self]::keys addItem $key
    [self]::keys setSelectedItem $key
}
IDE::ArrayBrowser instproc dispatchWithKey procName {
    set actual [[self]::keys selectedItem]
    if {$actual!=""} {
        my $procName $actual
    }
}
IDE::ArrayBrowser instproc editSave value {
    my instvar varray
    set key [[self]::keys selectedItem]
    if {$key==""} return
    my varAction set ${varray}($key) $value
}
IDE::ArrayBrowser instproc fillMenuStruct aMenuStruct {
    $aMenuStruct enablementHandler [self]

    $aMenuStruct addCommand2 {Add Key} [list [self] addKey] isValidSelection
    $aMenuStruct addCommand2 {Remove Key} [list [self] dispatchWithKey removeKey] isValidSelection
    $aMenuStruct addCommand2 {Inspect As Object} [list [self] dispatchWithKey inspectAsObject] isValidSelection
    $aMenuStruct addCommand2 {Inspect As Object List} [list [self] dispatchWithKey inspectAsObjectList] isValidSelection
    $aMenuStruct addCommand2 {Refresh} [list [self] initContents]
}
IDE::ArrayBrowser instproc getMenuStruct {} {
    return [IDE::MenuStruct [self]::ms Array 0]
}
IDE::ArrayBrowser instproc getTitle {} {
    return Array
}
IDE::ArrayBrowser instproc initContents {} {
    my instvar varray
    [self]::keys setList [my varAction array names $varray]
}
IDE::ArrayBrowser instproc inspectAsObject key {
    my instvar varray
    set obj [my varAction set ${varray}($key)]
    if {[Object isobject $obj]} {
        $obj inspect
    } else {
        IDE::Dialog error "$obj in not xotclide object"
    }
}
IDE::ArrayBrowser instproc inspectAsObjectList key {
    my instvar varray
    set list [my varAction set ${varray}($key)]
    set objects [list]
    foreach obj $list {
        if {[Object isobject $obj]} {
            lappend objects $obj
        }
    }
    if {[llength $objects]>0} {
        IDE::ObjectBrowser browseObjectsList $objects
    } else {
        IDE::Dialog message "There are no objects in the list"
    }
}
IDE::ArrayBrowser instproc isValidSelection {} {
    expr {[my set actual]!=""}
}
IDE::ArrayBrowser instproc removeKey key {
    my instvar varray
    my varAction unset ${varray}($key)
    [self]::keys removeItem $key
}
IDE::ArrayBrowser instproc selectKey key {
    my instvar varray
    my set actual $key
    [self]::edit setTextControler [my varAction set ${varray}($key)] [self]
}
IDE::ArrayBrowser instproc specificInit {} {
    my instvar win vobject varray
    my set actual {}

    IDE::NListView create [self]::keys $win.keys -notify [self] -notifyProc selectKey -height 25
    IDE::MethodEdit [self]::edit $win.edit -width 40

    grid $win.keys -row 0 -column 0 -sticky news
    grid $win.edit -row 0 -column 1 -sticky news
    grid rowconfigure $win 0 -weight 1
    grid columnconfigure $win 0 -weight 1
    grid columnconfigure $win 1 -weight 2

    my initContents
    my setTitleAddition "$vobject : $varray"
    next
}
IDE::ArrayBrowser instproc varAction args {
    my instvar vobject
    if {$vobject!=""} {
        $vobject eval $args
    } else {
        namespace eval :: $args
    }
}
IDE::ArrayBrowser proc inspectArray {object array} {
    set br [my create [Object autoname abrowser] [Object autoname .abrowser] -vobject $object -varray $array]
    return $br
}
IDE::ArrayBrowser proc inspectGlobalArray array {
    set br [my create [Object autoname abrowser] [Object autoname .abrowser] -vobject {} -varray $array]
    return $br
}
Class IDE::ClassDefinition -superclass ::IDE::Browser  -parameter {{superclassList {}} classView {mode create} {parameter {}} className}
@ ::IDE::ClassDefinition idemeta categories {initialize list_manipulation private}
@ ::IDE::ClassDefinition idemeta categoriesMethods {{getTitle createSystemMenu setClassesList specificInit} {upListElem downListElem delFromList addToList} getParameter}
@ ::IDE::ClassDefinition idemeta component IDEView
IDE::ClassDefinition instproc actionCreate {} {
    my instvar classView mode className
    if {[my checkClassView]} {
        if {$mode=="redefine"} {
            set parameter [my getParameter]
            set superclass [[self]::superclass getList]
            if {$parameter!=[$className info parameter]} {
                $className parameter $parameter
            }
            if {$superclass!=[$className info superclass] &&
                !($superclass=="" && [$className info superclass]=="::xotcl::Object")} {
                if {$superclass==""} {set superclass ::xotcl::Object}
                $className superclass $superclass
            }
        } else {
            if {[set def [my getClassDefinition]]==""} return
            $classView editSave $def
        }
    }
    my destroy
}
IDE::ClassDefinition instproc actionTemplate {} {
    my instvar classView
    set def [my getClassDefinition]
    if {$def==""} return
    if {[my checkClassView]} {
        $classView setEditText $def
        $classView set vclass {}
    }
    my destroy
}
IDE::ClassDefinition instproc addItemToList item {
    if {$item==""} return
    [self]::superclass addItemAtTail $item
    my setClassesList
}
IDE::ClassDefinition instproc addToList {} {
    my addItemToList [[self]::classlist selectedItem]
}
IDE::ClassDefinition instproc checkClassView {} {
    my instvar classView
    return [Object isobject $classView]
}
IDE::ClassDefinition instproc createSystemMenu {} {
    # no system menu
}
IDE::ClassDefinition instproc delFromList {} {
    my removeItemFromList [[self]::superclass selectedItem]
}
IDE::ClassDefinition instproc destroy {} {
    my instvar win
    ::destroy $win
    next
}
IDE::ClassDefinition instproc downListElem {} {
    [self]::superclass reorderSelected 1
}
IDE::ClassDefinition instproc getClassDefinition {} {
    my instvar win
    set name [$win.fname.name get]
    if {$name==""} {
        IDE::Dialog error "You must specify new name for the class"
        return
    }
    set parameter [my getParameter]
    if {![info complete $parameter]} {
        IDE::Dialog error "Parameter are not proper Tcl list"
        return
    }
    set def "Class $name"
    set superclass [[self]::superclass getList]
    if {[llength $superclass]>0} {
        append def " -superclass [list $superclass]"
    }
    if {$parameter!=""} {
        append def " -parameter [list $parameter]"
    }
    return $def
}
IDE::ClassDefinition instproc getParameter {} {
    my instvar win
    set parameter [$win.fpar.parameter get 1.0 end]
    return [string range $parameter 0 [expr {[string length $parameter] - 2}]]
}
IDE::ClassDefinition instproc getTitle {} {
    return {Class Definition}
}
IDE::ClassDefinition instproc removeItemFromList sitem {
    if {$sitem!=""} {
        [self]::superclass removeItem $sitem
        my setClassesList
    }
}
IDE::ClassDefinition instproc selectItem item {
    # only for IDE::NListView
}
IDE::ClassDefinition instproc setClassesList {} {
    my instvar compVisibility classView mode className
    if {!$compVisibility} {
        set clist [IDE::IntroProxy getClasses]
    } else {
        set clist [[$classView getActualComponentObject] getVisibleClasses]
    }
    set clist [ide::lcollect each $clist {string trimleft $each :}]
    set remove [list xotcl::Class xotcl::Object]
    if {$mode eq "redefine"} {
        lappend remove $className
    }
    set supclasses [[self]::superclass getList]
    foreach sclass $supclasses {
        lappend remove [string trimleft $sclass :]
        foreach c [$sclass info heritage] {
            lappend remove [string trimleft $c :]
        }
        foreach c [IDE::IntroProxy getSubclassesDeep $sclass] {
            lappend remove [string trimleft $c :]
        }
    }
    ide::lremoveAll clist $remove
    [self]::classlist setList $clist
}
IDE::ClassDefinition instproc specificInit {} {
    my instvar win superclassList mode className parameter

    frame $win.fname
    frame $win.buttons -relief raised -border 3
    frame $win.lframe
    frame $win.fpar

    entry $win.fname.name

    if {$mode=="redefine"} {
        $win.fname.name insert 0 $className
        $win.fname.name configure -state disabled
        set actionText Redefine
    } else {
        set actionText Create
    }
    button $win.buttons.ok -text $actionText -command [list [self] actionCreate]
    button $win.buttons.template -text "Edit Create Statement" -command [list [self] actionTemplate]
    button $win.buttons.cancel -text "Cancel" -command "destroy $win; [self] destroy" -underline 0

    pack $win.buttons.ok $win.buttons.template $win.buttons.cancel -side left

    IDE::NListView [self]::classlist $win.lframe.classlist -notify [self] -doubleNotifyProc addItemToList
    IDE::NListView [self]::superclass $win.lframe.superclass -notify [self] -doubleNotifyProc removeItemFromList

    label $win.fname.lname -text Name

    pack $win.fname.lname $win.fname.name -side left

    #label $win.lsuperclasses -text Superclasses
    checkbutton $win.lframe.visibility -text "classes visible in component only" -variable [self]::compVisibility -command [list [self] setClassesList]


    button $win.lframe.addtolist -text << -command [list [self] addToList]
    button $win.lframe.delfromlist -text del -command [list [self] delFromList]
    button $win.lframe.upitem -text up -command [list [self] upListElem]
    button $win.lframe.downitem -text down -command [list [self] downListElem]

    pack $win.lframe.visibility -side bottom -anchor e
    pack $win.lframe.superclass -side left -expand yes -fill both
    pack $win.lframe.classlist -side right -expand yes -fill both
    pack $win.lframe.addtolist -anchor s -fill x
    pack $win.lframe.delfromlist -anchor n -fill x
    pack $win.lframe.upitem -fill x
    pack $win.lframe.downitem -fill x

    label $win.fpar.lparameter -text "parameter f.e. \"parameter1 {parameter2 default2} parameter3\""
    text $win.fpar.parameter -height 6
    if {$parameter!=""} {
        $win.fpar.parameter insert 1.0 $parameter
    }
    pack $win.fpar.lparameter -anchor w
    pack $win.fpar.parameter -fill both -expand yes


    pack $win.fname -anchor w
    pack $win.lframe -expand 1 -fill both -pady 10
    pack $win.fpar -expand 1 -fill both
    pack $win.buttons -anchor w -ipady 10 -ipadx 6 -fill x

    set cancelscript "
               $win.buttons.cancel configure -state active -relief sunken
               update idletasks
               after 100
               [self] destroy"

    bind $win <Escape> $cancelscript
    bind $win <Alt-c> $cancelscript

    [self]::superclass setListUnsorted [ide::lcollect each $superclassList {string trimleft $each :}]
    my setClassesList
    next
    focus $win.fname.name
}
IDE::ClassDefinition instproc upListElem {} {
    [self]::superclass reorderSelected -1
}
IDE::ClassDefinition proc newChildClass {superclass view} {
    return [my new [Object autoname .cdbrowser] -classView $view -superclassList $superclass]
}
IDE::ClassDefinition proc newClass view {
    return [my new [Object autoname .cdbrowser] -classView $view]
}
IDE::ClassDefinition proc redefineClass {class view} {
    set superclass [$class info superclass]
    set parameter [$class info parameter]
    if {$superclass=="::Object" || $superclass=="::xotcl::Object"} { set superclass ""}
    return [my create [Object autoname changeBrowser] [Object autoname .cdbrowser] -classView $view -superclassList $superclass -mode redefine -parameter $parameter -className $class]
}
IDE::ClassDefinition proc unknown args {
    error "unknown method on [self] $args"
}
@ Class IDE::ClassSelector {
    description {A dialog for selecting classes
interafec is
IDE::ClassSelector getClass
cancel by returning {}}
}
Class IDE::ClassSelector
@ ::IDE::ClassSelector idemeta component IDEView
IDE::ClassSelector proc getClass {} {
    set d [IDE::IDialogEntry new -volatile -message {Give class name or glob patern} -entry *]
    if {[$d prompt]!="ok"} {
        return {}
    }
    set result [$d entry]

    if {[Object isobject $result] && ([$result istype Class] || [IDE::System info class]=="::xotcl::Object")} {
        return $result
    }
    set resultl [list]
    set clist [ide::lcollect each [IDE::IntroProxy getClasses] {string trimleft $each :}]
    if {$result=="*"} {
        set resultl $clist
    } else {
        foreach elem $clist {
            if {[string match $result $elem]} {
                lappend resultl $elem
            }
        }
    }
    if {[llength $resultl]==0} {
        IDE::Dialog message "Class or Object with name \"$result\" can not be found"
        return
    }
    set d2 [IDE::IDialogList new -volatile -message {Choose the class} -list [lsort $resultl]]
    if {[$d2 prompt]!="ok"} {
        return {}
    }
    set result [$d2 selectedItem]
    return $result
}
IDE::ClassSelector proc getUnregisteredClass {} {
    set result [IDE::IntroProxy getUnregisteredClasses]
    if {$result==""} {
        IDE::Dialog message "There are no unknown xotcl classes for XOTclIDE"
        return
    }
    set d [IDE::IDialogList new -volatile -message {Choose the class} -list [lsort $result]]
    if {[$d prompt]!="ok"} {
        return {}
    }
    set result [$d selectedItem]
    return $result
}
@ Class IDE::ClassView {
description {Warning

vclass varible hold an actual displayed object
it can by an real Xotcl Class or
IDE::ProcsGroup
a wrapper for structure tcl procs in groups}
}
Class IDE::ClassView -superclass {::IDE::AbstractClassView ::IDE::GUICommands ::IDE::FocusPerKey}  -parameter {{label Classes/Objects}}
@ ::IDE::ClassView idemeta categories {private class_actions service user_actions initialize}
@ ::IDE::ClassView idemeta categoriesMethods {{refreshView changeViewType setViewType dispatchWithSelectedNoGroup setEditText selectFor selectItem} {classTemplate copyClass classWizard deleteClass} getActualComponentObject {renameTclProcsGroup newTclProcsGroup createTclProcsGroup moveToComp} {getMenuStruct init fillMenuStruct}}
@ ::IDE::ClassView idemeta component IDEView
IDE::ClassView instproc buttonDoublePush {} {
    my instvar win selectedIndex listItems
    set currsel [lindex [$win.listbox curselection] 0]
    if {$currsel!=""} {
        my selectItem [string trimleft [lindex $listItems $currsel]]
    }
}
IDE::ClassView instproc buttonPush {} {
    my instvar win selectedIndex listItems
    set currsel [lindex [$win.listbox curselection] 0]
    if {$currsel!="" && $currsel!=$selectedIndex} {
        set selectedIndex $currsel
        my selectItem [string trimleft [lindex $listItems $currsel]]
    }
    focus [my getFocusWin]
}
IDE::ClassView instproc canModifyComponent {} {
    my instvar cobj
    if {[$cobj isPersistent] && ![$cobj questForChange]} {
        return 0
    } else {
        return 1
    }
}
IDE::ClassView instproc changeHeritageView {} {
    if {[my exists vcomponent]} {
        my selectFor [my set vcomponent]
    }
}
IDE::ClassView instproc changeViewType type {
    my set vtype $type
    if {[my exists vcomponent]} {
        my selectFor [my set vcomponent]
    }
}
IDE::ClassView instproc classTemplate {} {
    my unselect
    [my info parent]::methodedit setTextControler {Class YourClass -superclass YourSuperClass} [self]
}
IDE::ClassView instproc classWizard mode {
    set actual [my selectedItem]
    switch $mode {
        new {
            my setViewType {Classes}
            IDE::ClassDefinition newClass [self]
        }
        newChild {
            if {$actual==""} return
            IDE::ClassDefinition newChildClass $actual [self]
        }
        redefine {
            if {$actual==""} return
            IDE::ClassDefinition redefineClass $actual [self]
        }
    }
}
IDE::ClassView instproc copyClass actual {
    my instvar vcomponent
    set cobj [IDE::Component getCompObjectForNameIfExist $vcomponent]
    set newname [IDE::IDialogEntry getValue "Give Object/Class Copy Target Name"]
    if {$newname==""}  return
    if {[Object isobject $newname]} {
        IDE::Dialog message "Object $newname already exists!"
        return
    }
    set targetComp [IDE::IDialogList getListItem "Select target Component" [IDE::Component getComponentNames]]
    if {$targetComp==""} return
    $cobj copyClassOrObject $actual $newname $targetComp
}
IDE::ClassView instproc createTclProcsGroup {name withNamespace} {
    my instvar cobj
    if {![my canModifyComponent]} return

    $cobj createTclProcsGroup $name $withNamespace
    my setViewType {Tcl Procs}
}
IDE::ClassView instproc deleteClass actual {
    my instvar vtype vcomponent procsGroup

    set cobj [IDE::Component getCompObjectForNameIfExist $vcomponent]
    if {$cobj==""} return
    if {$vtype eq "Classes"} {
        if {[llength [set subclasses [$actual info subclass]]]>0} {
            IDE::Dialog message "$actual has subclasses and can not be removed yet: [join $subclasses {, }]. Remove the subclass dependiences first"
            return
        }
        if {[llength [set subclasses [$actual info classchildren]]]>0} {
            IDE::Dialog message "$actual has nested classes and can not be removed yet: [join $subclasses {, }]. Remove the nested classes first"
            return
        }
    }
    if {![my canModifyComponent]} return
    if {![IDE::Dialog yesNo "Do you really want to delete $actual"]} return
    my removeItem $actual
    if {[my isProcView]} {
        $cobj removeProcsGroup $procsGroup
    } else {
        if {[Object isclass $actual]} {
            $cobj removeClass $actual
        } else {
            $cobj removeObject $actual
        }
        $actual destroy
    }
    [my info parent]::methodcatview selectFor {} $vtype
}
IDE::ClassView instproc dispatchWithSelectedNoGroup procName {
    set actual [my selectedItem]
    if {$actual!=""} {
        if {[my set vtype]!="Tcl Procs"} {
            my $procName $actual
        } else {
            my upsMessage {you can not do this action on Tcl procs-group}
        }
    } else {
        my upsMessage {you need to select a item for this action}
    }
}
IDE::ClassView instproc editSave skript {
    my instvar vcomponent vtype vclass treeView
    if {![my exists vcomponent]} {
        IDE::Dialog message {Select the component first}
        return
    }
    if {![info complete $skript]} {
        IDE::Dialog message {This is not complete Tcl-Script. Check the paratness}
        return
    }
    if {[ide::lcontain {Object Class} [lindex $skript 0]] || [Object ismetaclass [lindex $skript 0]]} {
        if {[Object isobject [lindex $skript 1]]} {
            IDE::Dialog message {Operation is not permited. All Object methods are lost be redefinig the Object. Use class methods "superclass" or "parameter" for redefining}
            return
        }
    }
    # check if component is versioned
    if {![my canModifyComponent]} return

    if {[my isProcView]} {
        $vclass handleDefinitionScript $skript
        return
    }
    set newclass [string trimleft [namespace eval :: $skript] :]
    $newclass moveToComponent $vcomponent
    if {[$newclass istype Class]} {
        if {$vtype=="Classes"} {
            if {$treeView} {
                my changeHeritageView
            } else {
                my addItem $newclass
            }
        }
    } else {
        if {$vtype=="Objects"} {
            my addItem $newclass
        }
    }
}
IDE::ClassView instproc editSaveComment comment {
    my instvar vclass
    if {[Object isobject $vclass]} {
        $vclass setComment $comment
    }
}
IDE::ClassView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms enableList isValidContext

    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name Delete -command [list [self] dispatchWithSelected deleteClass] -enableList [list isValidSelection] -popdownMenu 1]
    $ms addCheckButton {Heritage View} [self]::treeView [list [self] changeHeritageView]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {Move To Comp.} -command [list [self] dispatchWithSelected moveToComp] -enableList [list isValidSelection] -popdownMenu 1]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {Copy Class/Object} -command [list [self] dispatchWithSelected copyClass] -enableList [list isValidSelection isSelectionNoGroup] -popdownMenu 1]
    $ms addCommand {New Class Template} [list [self] classTemplate]

    $ms addSeparator
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {New Class Wizard} -command [list [self] classWizard new] -popdownMenu 1]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {New Child Class Wizard} -command [list [self] classWizard newChild] -enableList [list isValidSelection isSelectionClass] -popdownMenu 1]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {Redefine Class Wizard} -command [list [self] classWizard redefine] -enableList [list isValidSelection isSelectionClass] -popdownMenu 1]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {New Object Wizard} -command [list [self] newObjectWizard] -popdownMenu 1]

    set tms ${ms}::tclprocs
    IDE::MenuStruct $tms {Tcl Procs Group}
    $tms enablementHandler [self]
    $ms addCascadeMenu $tms
    $tms addCommand {New Group} [list [self] newTclProcsGroup]
    $tms addMenuItem [IDE::MenuCommand new -childof $tms -name {Rename} -command [list [self] dispatchWithSelected renameTclProcsGroup] -enableList [list isValidSelection isProcView]]

    my menuInsertions $ms

    $ms addSeparator

    next

}
IDE::ClassView instproc getActualComponentObject {} {
    my set cobj
}
IDE::ClassView instproc getMenuStruct {} {
    return [IDE::MenuStruct create [self]::ms Class 2]
}
IDE::ClassView instproc init args {
    next
    my instvar win vtype
    my set treeView 0
    ::IDE::StateButton [self]::stateButton $win.tb_class -states {Classes Objects {Tcl Procs}} -command [list [self] changeViewType]
    set vtype Classes
    pack $win.tb_class -anchor w
}
IDE::ClassView instproc isProcView {} {
    my instvar vtype vclass
    if {$vtype=="Tcl Procs" &&
        [Object isobject $vclass] &&
        [$vclass istype IDE::ProcsGroup]} {
        return 1
    }
    return 0
}
IDE::ClassView instproc isSelectionClass {} {
    expr {[my set vtype]=="Classes"}
}
IDE::ClassView instproc isSelectionNoGroup {} {
    expr {[my set vtype]!="Tcl Procs"}
}
IDE::ClassView instproc isValidContext {} {
    expr {[my exists vcomponent] && [my set vcomponent]!=""}
}
IDE::ClassView instproc moveToComp actual {
    my instvar vcomponent vclass
    IDE::IDialogList [self]::dialog -message {Choose the Component}  -list [lsort [IDE::IntroProxy getComponents]]
    if {[[self]::dialog prompt]=="ok"} {
        set component [[self]::dialog selectedItem]
        if {$vcomponent==$component} return
        # check if source and target component can be changed
        if {![my canModifyComponent]} return
        set cobj [IDE::Component getCompObjectForName $component]
        if {[$cobj isPersistent] && ![$cobj questForChange]} return
        if {$component!=""} {
            $vclass moveToComponent $component
            my removeItem $actual
        }
    }
    [self]::dialog destroy
}
IDE::ClassView instproc newObjectWizard {} {
    set object [IDE::IDialogEntry getValue {Specify Object name}]
    if {$object==""} return
    if {![info complete $object] || [llength $object]>1} {
        IDE::Dialog error "Object name should be simple word (one list element) but got '$object'"
        return
    }
    [self]::stateButton changeStateTo Objects
    my editSave "Object $object"
}
IDE::ClassView instproc newTclProcsGroup {} {
    my instvar vcomponent
    if {$vcomponent==""} return
    IDE::TclGroupDefinition newGroup [self]
}
IDE::ClassView instproc refreshList {} {
    my selectFor [my set vcomponent]
}
IDE::ClassView instproc refreshView {} {
    my instvar vclass vtype
    set v [my info parent]::methodedit
    if {[$v set vtype]=="Source"} {
        if {[my isProcView]} {
            set text  [$vclass getDefBody]
        } else {
            set text  [IDE::IntroProxy getObjDef $vclass]
        }
        set hasComment [$vclass hasComment]
        $v setTextControler $text [self]
        set sb [my info parent]::stateButton
        if {[Object isobject $sb]} {
            $sb  setActivity $hasComment
        }
    } elseif {[$v set vtype]=="Comment"} {
        $v setTextControler [$vclass getComment] [self]
    } else {
        error {Unknown view type}
    }
}
IDE::ClassView instproc renameTclProcsGroup actual {
    my instvar vclass
    if {![$vclass istype IDE::ProcsGroup] && ![$vclass withNamespace]} return
    if {![my canModifyComponent]} return
    set newname [IDE::IDialogEntry getValue "Get new name for tcl proc group" [$vclass getObjectName]]
    if {$newname!="" && $newname!=[$vclass getObjectName]} {
        $vclass rename $newname
        my refreshList
    }
}
IDE::ClassView instproc selectFor component {
    my instvar vcomponent vtype cobj treeView
    set vcomponent $component
    if {$component==""} {
        my resetList
        set cobj {}
        [my info parent]::methodcatview selectFor {} $vtype
        return
    }
    set mtype $vtype
    set cobj [IDE::Component getCompObjectForNameIfExist $vcomponent]
    if {$cobj==""} {error "Can find component object for $vcomponent"}
    if {$mtype=="Tcl Procs"} {set mtype ProcsGroups}
    if {$treeView && $vtype=="Classes"} {
        my setHList [$cobj getClassesHierarchy]
    } else {
        my setList [lsort [IDE::IntroProxy get${mtype}ForComponent $component]]
    }
    my selectItem {}
}
IDE::ClassView instproc selectItem class {
    my instvar vtype vclass procsGroup cobj
    if {[Object isobject [my info parent]::methodcatview]} {
        [my info parent]::methodcatview selectFor $class $vtype
    }
    if {$class==""} {
        set vclass {}
        return
    }
    if {$vtype=="Tcl Procs"} {
        set procsGroup [$cobj getProcsGroupWithName $class]
        set vclass $procsGroup
    } else {
        set vclass $class
    }
    my refreshView
}
IDE::ClassView instproc setEditText text {
    [my info parent]::methodedit setTextControler $text [self]
    [my info parent]::methodedit ignoreNoChanges
}
IDE::ClassView instproc setViewType type {
    [self]::stateButton setState $type
    my changeViewType $type
}
@ Class IDE::CodeController {
description {This class is designed as mixin for IDE::TclModeEdit it can accept the
code from the edit directly.}
}
Class IDE::CodeController
@ ::IDE::CodeController idemeta component IDEView
IDE::CodeController instproc editSave skript {
    if {![info complete $skript]} {
        IDE::Dialog message {This is not complete Tcl-Script. Check the paratness}
        return
    }
    if {[lindex $skript 0]=="proc"} {
        my handleProc $skript
    } else {
        namespace eval :: $skript
    }
}
IDE::CodeController instproc editSaveComment comment {
    my instvar actItem
    set vclass [lindex $actItem 0]
    set vtype [lindex $actItem 1]
    set method [lindex $actItem 2]
    $vclass setMethodComment $vtype $method $comment
}
IDE::CodeController instproc handleProc script {
    if {[llength $script]!=4 || [lindex $script 0]!="proc"} {
        IDE::Dialog error "To define new tcl proc give 4 elements list\n proc ?nameSpace::?procName arguments procBody"
        return
    }
    set procname [lindex $script 1]
    set pobj [IDE::TclProcsDescription getMethodFor $procname]
    if {$pobj=="" || ![Object isobject $pobj]} {
        IDE::Dialog error "It is not good place to define procs. Use component browser instead"
        return
    }
    [$pobj getGroupObj] handleScript $script
}
IDE::CodeController instproc refreshView {} {
    my instvar actitem
    set class [lindex $actitem 0]
    set type [lindex $actitem 1]
    set method [lindex $actitem 2]
    set v [my info parent]::methodedit
    if {[$v set vtype]=="Comment"} {
        set comment [$class getMethodComment $type $method]
        my setTextControler $comment [self]
    } elseif {[$v set vtype]=="Source"} {
        my setBodyTextControler $class $type $method [self]
        set sb [my info parent]::stateButton
        if {[Object isobject $sb]} {
            set hasComment [$class hasMethodComment $type $method]
            $sb  setActivity $hasComment
        }
    }
}
IDE::CodeController instproc setBodyText {class type method} {
    my instvar actitem
    my set actitem [list $class $type $method]
    my refreshView
}
IDE::CodeController instproc setTextType {text type} {
    my setTextTypeControler $text $type [self]
}
IDE::CodeController instproc syntaxCheck {text editor} {
    # !! method is double to IDE::MethodView
    set context [PrsContext new -volatile]
    $context parseAndCheck $text
    if {[$context hasErrors]} {
        IDE::SyntaxErrorView new -errors [$context errors] -controler [self] -editor $editor -init [Object autoname .syntaxview]
        return 0
    } else {
        return 1
    }
}
@ Class IDE::CompBrowser {
description {Build the main work tool for an XOTclIDE programmer

If there is Version Control available it
create its commonent from another class with
pre IDE::DB* see specificInit method
}
}
Class IDE::CompBrowser -superclass ::IDE::Browser
@ ::IDE::CompBrowser idemeta component IDEView
IDE::CompBrowser instproc changeZoom {} {
    my instvar win sashpadYpos
    if {[winfo viewable $win.upperarea]} {
        $win.panedwindow forget $win.upperarea
        set sashpadYpos [lindex [$win.panedwindow proxy coord] 1]
    } else {
        $win.panedwindow add $win.upperarea -before $win.methodedit -height $sashpadYpos
    }
}
IDE::CompBrowser instproc getActualComponentObject {} {
    [self]::appview getActualComponentObject
}
IDE::CompBrowser instproc getTitle {} {
    return {Component Browser}
}
IDE::CompBrowser instproc initStatusBarWin win {
    my instvar statusBarTextWin
    frame $win
    label $win.label -anchor w
    set statusBarTextWin $win.label
    IDE::StateButtonActivity [self]::stateButton $win.stateBut -states {Source Comment} -command [list [self]::methodedit changeViewType]
    bind [winfo toplevel $win] <Alt-u> [list $win.stateBut invoke]
    pack $win.label  -side left
    pack $win.stateBut -side right
}
IDE::CompBrowser instproc refreshHItem hitem {
    set vclass [lindex $hitem 0]
    set vctype [lindex $hitem 1]
    set method [lindex $hitem 2]
    if {$vctype=="Tcl Procs"} {
        if {[Object isobject $vclass]} {
            set cobj [$vclass getComponent]
            [self]::appview setSelectedItem [$cobj getName]
            [self]::classview::stateButton changeStateTo "Tcl Procs"
            [self]::classview setSelectedItem [$vclass getName]
        }
    } else {
        set cobj [$vclass getCompObject]
        [self]::appview setSelectedItem [$cobj getName]
        if {[Object isclass $vclass]} {
            set needState Classes
        } else {
            set needState Objects
        }
        [self]::classview::stateButton changeStateTo $needState
        [self]::classview setSelectedItem $vclass
        [self]::methodcatview::stateButton changeStateTo $vctype
        [self]::methodcatview setSelectedItem _all_categories
    }
}
IDE::CompBrowser instproc specificInit {} {
    my instvar win vtype

    set vtype Source

    # The simplest factory pattern case in the free world
    if {[IDE::System isDatabase]} {
        set postFix DB
    } else {
        set postFix ""
    }

    if {[IDE::System isTkNeverThan84]} {
        panedwindow $win.panedwindow -orient vertical
        panedwindow $win.upperarea -orient horizontal

        IDE::CompView${postFix} create [self]::appview $win.upperarea.appview -focusKey {Alt-KeyPress-1} -nextFocus $win.upperarea.classview.listbox -prevFocus $win.upperarea.methodview.listbox -height 1
        IDE::TclModeEdit create [self]::methodedit $win.methodedit
        IDE::ClassView${postFix} create [self]::classview $win.upperarea.classview -focusKey {Alt-KeyPress-2} -label {Classes/Objects Alt-2} -nextFocus $win.upperarea.methodcatview.listbox -prevFocus $win.upperarea.appview.listbox  -height 1
        IDE::MethodCategoryView create [self]::methodcatview $win.upperarea.methodcatview -focusKey {Alt-KeyPress-3} -label {Categories Alt-3} -nextFocus $win.upperarea.methodview.listbox -prevFocus $win.upperarea.classview.listbox  -height 1
        IDE::MethodView${postFix} create [self]::methodview $win.upperarea.methodview  -focusKey {Alt-KeyPress-4} -label {Methods Alt-4} -prevFocus $win.upperarea.methodcatview.listbox -nextFocus $win.methodedit.text -multiselect 1 -height 1

        $win.upperarea add $win.upperarea.appview  $win.upperarea.classview $win.upperarea.methodcatview $win.upperarea.methodview -width 200

        $win.panedwindow add $win.upperarea -sticky news -height  220
        $win.panedwindow add $win.methodedit -sticky news -height 200

        pack $win.panedwindow -expand yes -fill both
    } else {
        IDE::CompView${postFix} create [self]::appview $win.appview -focusKey {Alt-KeyPress-1} -nextFocus $win.classview.listbox -prevFocus $win.methodview.listbox
        IDE::TclModeEdit create [self]::methodedit $win.methodedit
        IDE::ClassView${postFix} create [self]::classview $win.classview -focusKey {Alt-KeyPress-2} -label {Classes/Objects Alt-2} -nextFocus $win.methodcatview.listbox -prevFocus $win.appview.listbox
        IDE::MethodCategoryView create [self]::methodcatview $win.methodcatview -focusKey {Alt-KeyPress-3} -label {Categories Alt-3} -nextFocus $win.methodview.listbox -prevFocus $win.classview.listbox
        IDE::MethodView${postFix} create [self]::methodview $win.methodview  -focusKey {Alt-KeyPress-4} -label {Methods Alt-4} -prevFocus $win.methodcatview.listbox -nextFocus $win.methodedit.text -multiselect 1

        grid $win.appview -row 0 -column 0 -sticky news
        grid $win.classview -row 0 -column 1 -sticky news
        grid $win.methodcatview -row 0 -column 2 -sticky news
        grid $win.methodview -row 0 -column 3 -sticky news
        grid $win.methodedit -row 1 -column 0 -columnspan 4 -sticky news

        grid columnconfigure $win 0 -weight 1
        grid columnconfigure $win 1 -weight 1
        grid columnconfigure $win 2 -weight 1
        grid columnconfigure $win 3 -weight 1
        grid rowconfigure $win 1 -weight 1
    }
    my initStatusBar 2 4

    next
}
IDE::CompBrowser proc newBrowser {} {
    return [my new [Object autoname .compbrowser]]
}
Class IDE::CompView -superclass {::IDE::ListView ::IDE::GUICommands ::IDE::FocusPerKey}  -parameter {{label {Components Alt-1}}}
@ ::IDE::CompView idemeta categories {system_actions initialize user_actions}
@ ::IDE::CompView idemeta categoriesMethods {{setAutoPath refreshFromInterpreter runPkgMkIndex} {getMenuStruct init fillMenuStruct} {createNewComponent saveAsSource importFromSource renameComponent loadFromSource registerClass unloadComponent newComponent registerTclProcs searchClass setVersion loadPackage}}
@ ::IDE::CompView idemeta component IDEView
IDE::CompView instproc changeWorkingDir {} {
    set newdir [IDE::Dialog getDir [pwd]]
    if {$newdir!=""} {
        cd $newdir
    }
}
IDE::CompView instproc createNewComponent component {
    IDE::Component getCompObjectForName $component
    IDE::System signalComponentsChanged
}
IDE::CompView instproc editSave comment {
    my editSaveComment $comment
}
IDE::CompView instproc editSaveComment comment {
    my instvar vcomponent
    set cobj [IDE::Component getCompObjectForNameIfExist $vcomponent]
    if {$cobj!=""} {
        $cobj setComment $comment
    }
}
IDE::CompView instproc fillMenuStruct ms {
    $ms enablementHandler [self]

    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name New -command [list [self] newComponent] -popdownMenu 1]
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -accelerator {Control-f} -name {Find Class} -command [list [self] searchClass] -popdownMenu 1]
    $ms addCheckButton {Ignore IDE Components} [self]::visibilityNoIDE [list [self] showComponents]
    $ms addSeparator
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name Rename -command [list [self] dispatchWithSelected renameComponent] -popdownMenu 1 -enableList [list isValidSelection]]
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name {Set Version Number} -command [list [self] dispatchWithSelected setVersion] -popdownMenu 1 -enableList [list isValidSelection]]
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name {Save as Source} -command [list [self] dispatchWithSelected saveAsSource] -popdownMenu 0 -enableList [list isValidSelection]]
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name Unload -command [list [self] dispatchWithSelected unloadComponent] -popdownMenu 1 -enableList [list isValidSelection]]
    $ms addSeparator
    IDE::MenuStruct ${ms}::spezial {Low level Functions}
    $ms addCascadeMenu ${ms}::spezial
    ${ms}::spezial addCommand {Refresh From Interp} [list [self] refreshFromInterpreter]
    ${ms}::spezial addCommand3 {Register Class From Interp} [list [self] dispatchWithSelected registerClass] isValidSelection
    ${ms}::spezial addCommand3 {Register Tcl proc From Interp} [list [self] registerTclProcs] isValidSelection

    ${ms}::spezial addCommand {Run pkg_mkIndex} [list [self] runPkgMkIndex]
    ${ms}::spezial addCommand {Change Working Dir} [list [self] changeWorkingDir]
    ${ms}::spezial addCommand {Run Script} [list [self] loadFromSource]

    #$ms addCommand {Set auto_path} [list [self] setAutoPath]
    $ms addCommand {Load Package} [list [self] loadPackage]
    $ms addCommand {Import Source} [list [self] importFromSource]
    my menuInsertions $ms
    $ms addSeparator
    $ms addCommand {Save Components} [list IDE::ComponentSaveWizard newBrowser]
    $ms addCommand {Save All} [list IDE::Component saveAllToPath]
    next
}
IDE::CompView instproc getActualComponentObject {} {
    set actual [my selectedItem]
    if {$actual==""} return
    return [IDE::Component getCompObjectForNameIfExist $actual]
}
IDE::CompView instproc getMenuStruct {} {
    return [IDE::MenuStruct [self]::ms Component 0]
}
IDE::CompView instproc importFromSource {} {
    set source [IDE::Dialog getOpenFile {{{Tcl Files} *.tcl} {{Xotcl Files} *.xotcl} {{All files} *}}]
    if {$source!=""} {
        IDE::Component importCompsFromFile $source
        IDE::System signalComponentsChanged
    }
}
IDE::CompView instproc init args {
    next
    my instvar visibilityNoIDE
    set visibilityNoIDE [IDE::System isIgnoreIDEComponents]
    my showComponents
}
IDE::CompView instproc loadFromSource {} {
    set source [IDE::Dialog getOpenFile {{{Tcl Files} *.tcl} {{Xotcl Files} *.xotcl} {{All files} *}}]
    if {$source!=""} {
        IDE::Component loadCompFromFile $source
    }
}
IDE::CompView instproc loadPackage {} {
    set loadedcomps [IDE::Component getComponentNames]
    set packages [list]
    foreach p [package names] {
        if {![ide::lcontain $loadedcomps $p]} {
            lappend packages $p
        }
    }
    IDE::IDialogListEntry [self]::dialog -message {Warnig: experimental. Load xotcl package or any tcl package aviable for your system by package require} -list [lsort $packages]
    if {[[self]::dialog prompt]=="ok"} {
        set ret [[self]::dialog getvalue]
        IDE::Component loadPackage $ret
        IDE::System signalComponentsChanged
    }
    [self]::dialog destroy
}
IDE::CompView instproc newComponent {} {
    set component [IDE::IDialogEntry getValue {Enter the component name}]
    if {$component!=""} {
        if {![regexp {^[\w:]+$} $component]} {
            IDE::Dialog error {Wrong name for the component}
            return
        }
        # The component should not already exits
        if {$component!="" && [IDE::Component getCompObjectForNameIfExist $component]==""} {
            my createNewComponent $component
        }
    }
}
IDE::CompView instproc refreshFromInterpreter {} {
    IDE::CommentsContainer parseAndCleanMeta
    IDE::Component initFromInterpreter
    my showComponents
}
IDE::CompView instproc refreshView {} {
    my instvar vcomponent
    set v [my info parent]::methodedit
    $v setTextControler [[IDE::Component getCompObjectForNameIfExist $vcomponent] getComment] [self]
}
IDE::CompView instproc registerClass actual {
    set cls [IDE::ClassSelector getUnregisteredClass]
    if {$cls==""} return
    if {![[my info parent]::classview canModifyComponent]} return
    $cls moveToComponent $actual
}
IDE::CompView instproc registerTclProcs {} {
    IDE::ImportMethodView startBrowserForComponent [IDE::Component getCompObjectForNameIfExist [my set vcomponent]]
}
IDE::CompView instproc renameComponent component {
    set compObj [IDE::Component getCompObjectForName $component]
    set ret [IDE::IDialogEntry getValue {Enter new name for the component} [$compObj getName]]
    if {$ret!="" && $ret!=[$compObj getName]} {
        if {![regexp {^[\w:]+$} $ret]} {
            IDE::Dialog error {Wrong name for the component}
            return
        }
        $compObj rename $ret
        IDE::System signalComponentsChanged
    }
}
IDE::CompView instproc runPkgMkIndex {} {
    pkg_mkIndex -direct [pwd] *.xotcl
    IDE::Dialog message "command \"pkg_mkIndow -direct [pwd] *.xotcl\" succesful finished"
}
IDE::CompView instproc saveAsSource actual {
    set source [IDE::Dialog getSaveFile $actual.xotcl]
    if {$source!=""} {
        [IDE::Component getCompObjectForName $actual] saveAsScript $source
    }
}
IDE::CompView instproc searchClass {} {
    set class [IDE::ClassSelector getClass]
    if {$class==""} return
    my setSelectedItem [$class getComponentName]
    if {[$class isclass]} {
        set shouldView Classes
    } else {
        set shouldView Objects
    }
    if {[[my info parent]::classview set vtype]!=$shouldView} {
        [my info parent]::classview::stateButton changeStateTo $shouldView
    }
    [my info parent]::classview setSelectedItem [string trimleft $class :]
}
IDE::CompView instproc selectItem item {
    if {[Object isobject [my info parent]::classview]} {
        [my info parent]::classview selectFor $item
    }
    my set vcomponent $item
    my refreshView
    [my info parent] setTitleAddition $item
}
IDE::CompView instproc setAutoPath {} {
    global auto_path
    set ret [IDE::IDialogEntry getValue {Set auto_path global varible} $auto_path]
    if {$ret!=""} {
        set auto_path $ret
    }
}
IDE::CompView instproc setVersion actual {
    set appObj [IDE::Component getCompObjectForName $actual]
    set ret [IDE::IDialogEntry getValue {Set the Version Number} [$appObj getVersionNumber]]
    if {$ret!=""} {
        if {![catch {expr {$ret+0}}]} {
            $appObj setVersionNumber $ret
        } else {
            IDE::Dialog error "$ret is wrong version number"
        }
    }
}
IDE::CompView instproc showComponents {} {
    my instvar visibilityNoIDE
    if {$visibilityNoIDE} {
        my setList [IDE::IntroProxy getComponentsNoIDE]
    } else {
        my setList [IDE::IntroProxy getComponents]
    }
}
IDE::CompView instproc unloadComponent actual {
    set reqComp [IDE::System getCoreComponentsAll]
    if {[::ide::lcontain $reqComp $actual]} {
        IDE::Dialog message "You can not unload this IDE-System Component [list $reqComp]"
        return
    }
    set appObj [IDE::Component getCompObjectForName $actual]
    set reqFor [$appObj getRequiredFor]
    if {$reqFor!=""} {
        IDE::Dialog message "You can not unload $actual. It is required from $reqFor"
        return
    }
    $appObj unload
    [my info parent]::classview selectFor {}
    IDE::System signalComponentsChanged
}
Class IDE::ComponentSaveWizard -superclass ::IDE::Browser
@ ::IDE::ComponentSaveWizard idemeta component IDEView
IDE::ComponentSaveWizard instproc actionSave {} {
    my instvar nometa onefile targetDir createPkgIndex
    set comps [[self]::savecomp getList]
    if {$comps==""} {
        IDE::Dialog message "No components to save were selected"
        return
    }
    IDE::Component saveComplex $comps $nometa $onefile $targetDir
    if {$createPkgIndex} {
        pkg_mkIndex -direct [pwd] *.xotcl
    }
    my destroy
}
IDE::ComponentSaveWizard instproc addAllToList {} {
    foreach item [[self]::complist getList] {
        my addItem $item
    }
}
IDE::ComponentSaveWizard instproc addItem item {
    if {$item==""} return
    [self]::savecomp addItem $item
}
IDE::ComponentSaveWizard instproc addToList {} {
    my addItem [[self]::complist selectedItem]

}
IDE::ComponentSaveWizard instproc changeDir {} {
    my instvar targetDir win
    set targetDir [IDE::Dialog getDir $targetDir]
    $win.tframe.target configure -text $targetDir
}
IDE::ComponentSaveWizard instproc createSystemMenu {} {
    # no system menu
}
IDE::ComponentSaveWizard instproc delFromList {} {
    my delItem [[self]::savecomp selectedItem]
}
IDE::ComponentSaveWizard instproc delItem item {
    if {$item!=""} {
        [self]::savecomp removeItem $item
    }
}
IDE::ComponentSaveWizard instproc getTitle {} {
    return {Component Save Wizard}
}
IDE::ComponentSaveWizard instproc selectItem item {
    # needed because of IDE::NListView
}
IDE::ComponentSaveWizard instproc setComponentList {} {
    my instvar compVisibility
    if {!$compVisibility} {
        [self]::complist setList [IDE::IntroProxy getComponents]
    } else {
        [self]::complist setList [IDE::IntroProxy getComponentsNoIDE]
    }
}
IDE::ComponentSaveWizard instproc specificInit {} {
    my instvar win mode className parameter targetDir

    my requireNamespace
    set targetDir {}

    frame $win.buttons -relief raised -border 3
    frame $win.lframe
    frame $win.tframe

    label $win.infolabel -text "Select components to save"

    IDE::NListView [self]::complist $win.lframe.complist -notify [self] -doubleNotifyProc addItem
    IDE::NListView [self]::savecomp $win.lframe.savecomp  -notify [self] -doubleNotifyProc delItem

    my set compVisibility [IDE::System isIgnoreIDEComponents]
    checkbutton $win.lframe.visibility -text "no ide components" -variable [self]::compVisibility -command [list [self] setComponentList]

    button $win.lframe.addtolist -text < -command [list [self] addToList]
    button $win.lframe.addalltolist -text << -command [list [self] addAllToList]
    button $win.lframe.delfromlist -text del -command [list [self] delFromList]

    pack $win.lframe.visibility -side bottom -anchor e
    pack $win.lframe.savecomp -side left -expand yes -fill both
    pack $win.lframe.complist -side right -expand yes -fill both
    pack $win.lframe.addtolist -anchor s -fill x
    pack $win.lframe.addalltolist -anchor s -fill x
    pack $win.lframe.delfromlist -anchor n -fill x

    label $win.ltarget -text "Target Dir"

    label $win.tframe.target -border 2 -width 40 -relief sunken -anchor w
    button $win.tframe.change -text "Change" -command [list [self] changeDir]
    pack $win.tframe.target $win.tframe.change -side left

    checkbutton $win.nometa -text "no meta data @" -variable [self]::nometa
    checkbutton $win.onefile -text "as one file" -variable [self]::onefile
    checkbutton $win.makepkgindex -text "create pkgIndex" -variable [self]::createPkgIndex

    button $win.buttons.ok -text Save -command [list [self] actionSave]
    button $win.buttons.cancel -text "Cancel" -command [list [self] destroy]
    pack $win.buttons.ok $win.buttons.cancel -side left

    pack $win.infolabel -anchor w
    pack $win.lframe -expand 1 -fill both -pady 10
    pack $win.ltarget -anchor w
    pack $win.tframe -fill x
    pack $win.nometa $win.onefile $win.makepkgindex -anchor w
    pack $win.buttons -anchor w -ipady 10 -ipadx 6 -fill x

    [self]::savecomp setList {}
    my setComponentList
    next
}
IDE::ComponentSaveWizard proc newBrowser {} {
    return [my new [Object autoname .cswbrowser]]
}
Class IDE::ConfigurationBrowser -superclass {::IDE::Browser ::IDE::GUICommands}  -parameter {{atHead 1}}
@ ::IDE::ConfigurationBrowser idemeta categories {initialization list-manipulation private user-action}
@ ::IDE::ConfigurationBrowser idemeta categoriesMethods {{getMenuStruct setComponentList destroy fillMenuStruct specificInit} {downListElem upListElem selectCompVersion selectComponent delFromList addToList} {updateCompList changeViewType} {initCompList saveAsFile loadFromFile initFromSystem loadComponents}}
@ ::IDE::ConfigurationBrowser idemeta component IDEView
IDE::ConfigurationBrowser instproc addElemToList item {
    [self]::confapp addItemAtTail $item
}
IDE::ConfigurationBrowser instproc addToList {} {
    set item [[self]::applist selectedItem]
    if {$item eq ""} return
    my addElemToList $item
}
IDE::ConfigurationBrowser instproc addUnmanagedPackage {} {
    set package [IDE::IDialogEntry getValue "Specify a tcl package that can be loaded per.\n  package require\n and is not managed by xotclide.\nWarning no syntax checking are possible!"]
    if {$package!=""} {
        [self]::confapp addItemAtTail $package
    }
}
IDE::ConfigurationBrowser instproc changeViewType type {
    my set vtype $type
    [self]::configedit setTextControler [IDE::SystemConfigMap getValueForType $type] [self]
}
IDE::ConfigurationBrowser instproc checkRequirements {} {
    [self]::confapp unselect
    set res  [IDE::SystemConfigMap checkRequirements [[self]::confapp getList]]
    my unselectComponent
    if {$res!=""} {
        [self]::confapp setListUnsorted $res
    }
}
IDE::ConfigurationBrowser instproc delFromList {} {
    set sitem [[self]::confapp selectedItem]
    if {$sitem!=""} {
        [self]::confapp removeItem $sitem
    }
    my unselectComponent
}
IDE::ConfigurationBrowser instproc destroy {} {
    my updateCompList
    next
}
IDE::ConfigurationBrowser instproc downListElem {} {
    [self]::confapp reorderSelected 1
}
IDE::ConfigurationBrowser instproc editSave text {
    IDE::SystemConfigMap setValueForType [my set vtype] $text
}
IDE::ConfigurationBrowser instproc fillMenuStruct aMenuStruct {
    $aMenuStruct enablementHandler [self]
    $aMenuStruct addCommand {Load Configuration Map} [list [self] loadFromFile]
    $aMenuStruct addCommand3 {Save Configuration Map as} [list [self] saveAsFile {}] hasComponents
    $aMenuStruct addCommand {Drop Comp List Changes} [list [self] initCompList]
    $aMenuStruct addCommand {Add Unmanaged Package} [list [self] addUnmanagedPackage]
    $aMenuStruct addSeparator
    $aMenuStruct addCommand3 {Deploy as File-Collection} [list [self] saveDistribution] hasComponents
    $aMenuStruct addCommand3 {Deploy as Tclkit} [list [self] saveAsTclkit] hasComponents
    $aMenuStruct addSeparator
    $aMenuStruct addCommand {Init from System} [list [self] initFromSystem]
    $aMenuStruct addCommand3 {Load Components} [list [self] loadComponents] hasComponents
    $aMenuStruct addCommand3 {Save ConfigMap Components} [list IDE::SystemConfigMap saveConfigMapComponents] hasComponents
    $aMenuStruct addSeparator
    $aMenuStruct addCommand3 {Run Start Scripts} [list IDE::SystemConfigMap startScripts] hasComponents
}
IDE::ConfigurationBrowser instproc getMenuStruct {} {
    return [IDE::MenuStruct [self]::ms Configuration 0]
}
IDE::ConfigurationBrowser instproc getTitle {} {
    return {Configuration Map Browser}
}
IDE::ConfigurationBrowser instproc hasComponents {} {
    expr {[llength [[self]::confapp getList]]>0}
}
IDE::ConfigurationBrowser instproc initCompList {} {
    set list [IDE::SystemConfigMap getValueForType componentsToLoad]
    [self]::confapp setListUnsorted  [lrange $list 0 end]
}
IDE::ConfigurationBrowser instproc initFromSystem {} {
    my instvar vtype
    IDE::SystemConfigMap initFromSystem
    my initCompList
    my changeViewType $vtype
}
IDE::ConfigurationBrowser instproc loadComponents {} {
    IDE::SystemConfigMap loadComponents
    my initCompList
}
IDE::ConfigurationBrowser instproc loadFromFile {} {
    my instvar vtype
    IDE::SystemConfigMap loadFromFile {}
    my initCompList
    my changeViewType $vtype
}
IDE::ConfigurationBrowser instproc saveAsFile args {
    my updateCompList
    IDE::SystemConfigMap saveAsFile {}
}
IDE::ConfigurationBrowser instproc saveAsTclkit {} {
    my updateCompList
    IDE::PlugInsManager loadExtras TclKitDeployer
}
IDE::ConfigurationBrowser instproc saveDistribution {} {
    my updateCompList
    IDE::SystemConfigMap saveDistribution
}
IDE::ConfigurationBrowser instproc selectCompVersion version {
    my instvar selectedCompItem
    if {$version=="automatic"} {
        set new [lindex $selectedCompItem 0]
    } elseif {$version=="package"} {
        set new [list [lindex $selectedCompItem 0] package]
    } else {
        set new [list [lindex $selectedCompItem 0] [lindex $version 0]]
    }
    [self]::confapp renameItemUnsorted $selectedCompItem $new
    set selectedCompItem $new
}
IDE::ConfigurationBrowser instproc selectComponent compItem {
    my instvar compVersionCash selectedCompItem
    if {![IDE::System isDatabase]} return
    set selectedCompItem $compItem
    set comp [lindex $compItem 0]

    if {![info exists compVersionCash($comp)]} {
        set compVersionCash($comp) [IDE::ComponentPersistence getVersionsForName $comp]
    }
    [self]::appversion setListUnsorted [concat automatic package $compVersionCash($comp)]
    set version [lindex $compItem 1]
    if {$version==""} {[self]::appversion setSelectedItem automatic 0; return}
    if {$version=="package"} {[self]::appversion setSelectedItem package 0; return}
    set i 0
    foreach item $compVersionCash($comp) {
        if {$version==[lindex $item 0]} {
            [self]::appversion setSelectedIndex [expr {$i+2}] 0
            return
        }
        incr i
    }
}
IDE::ConfigurationBrowser instproc setComponentList {} {
    my instvar compVisibility classView
    if {!$compVisibility} {
        [self]::applist setList [IDE::IntroProxy getComponents]
    } else {
        [self]::applist setList [IDE::IntroProxy getComponentsNoIDE]
    }
}
IDE::ConfigurationBrowser instproc specificInit {} {
    my instvar win

    panedwindow $win.panedwindow -orient vertical
    frame $win.lframe
    frame $win.bframe
    frame $win.lframe.comp

    IDE::NListView [self]::confapp $win.lframe.comp.confapp -notify [self] -notifyProc selectComponent -height 1
    IDE::NListView [self]::appversion $win.lframe.comp.appversion -notify [self] -notifyProc selectCompVersion -height 3
    label $win.lframe.comp.label -text {Versions Options}
    button $win.lframe.comp.checkreq -text {Check Requirements} -command [list [self] checkRequirements]

    pack $win.lframe.comp.confapp -expand yes -fill both
    pack $win.lframe.comp.label -anchor w
    pack $win.lframe.comp.appversion -fill x
    pack $win.lframe.comp.checkreq -anchor w

    IDE::ListView [self]::applist $win.lframe.classlist

    my set compVisibility [IDE::System isIgnoreIDEComponents]
    checkbutton $win.lframe.visibility -text "no IDE components" -variable [self]::compVisibility -command [list [self] setComponentList]

    button $win.lframe.addtolist -text << -command [list [self] addToList]
    button $win.lframe.delfromlist -text del -command [list [self] delFromList]
    button $win.lframe.upitem -text up -command [list [self] upListElem]
    button $win.lframe.downitem -text down -command [list [self] downListElem]

    IDE::MethodEdit [self]::configedit $win.cedit -height 1
    IDE::StateButton [self]::cbutton $win.cbutton  -states {preStartScript startScript} -command [list [self] changeViewType]

    pack $win.lframe.visibility -side bottom -anchor e
    pack $win.lframe.comp -side left -expand yes -fill both
    pack $win.lframe.classlist -side right -expand yes -fill both
    pack $win.lframe.addtolist -anchor s -fill x
    pack $win.lframe.delfromlist -anchor n -fill x
    pack $win.lframe.upitem -fill x
    pack $win.lframe.downitem -fill x

    pack $win.cedit -expand yes -fill both -in $win.bframe
    pack $win.cbutton -anchor w -in $win.bframe

    $win.panedwindow add $win.lframe -sticky news -height 200
    $win.panedwindow add $win.bframe -sticky news -height 200
    pack $win.panedwindow -expand yes -fill both

    [self]::cbutton setState startScript
    my changeViewType startScript

    my setComponentList
    my initCompList
    next
}
IDE::ConfigurationBrowser instproc unselectComponent {} {
    my set selectedCompItem {}
    [self]::appversion setListUnsorted {}
}
IDE::ConfigurationBrowser instproc upListElem {} {
    [self]::confapp reorderSelected -1
}
IDE::ConfigurationBrowser instproc updateCompList {} {
    IDE::SystemConfigMap setValueForType componentsToLoad [[self]::confapp getList]
}
IDE::ConfigurationBrowser proc hasView {} {
    expr  {[llength [my info instances]]!=0}
}
IDE::ConfigurationBrowser proc showBrowser {} {
    set first [lindex [my info instances] 0]
    if {$first==""} {
        my create confbrowser [Object autoname .browser]
    }
}
@ Class IDE::ContextEval {
    description {This class is used for mixins to overwrite the string
        evalution from selected text.

        please init the instance variable "context" with the contex object.
        All eval are do by using

        $context eval $script}
}
Class IDE::ContextEval
@ ::IDE::ContextEval idemeta component IDEView
IDE::ContextEval instproc evalString string {
    [my set context] eval $string
}
Class IDE::Deployer -superclass ::IDE::Browser
@ ::IDE::Deployer idemeta component IDEView
IDE::Deployer instproc actionGenerate {} {
    my instvar targetDir nometa onefile nopackages configName
    set compToSave [my getComponentsToDeploy]
    if {[llength $compToSave]==0} return

    my prepareDirectory

    if {!$onefile} {
        foreach cobj $compToSave {
            $cobj saveAsScript [$cobj standardFileName] $nometa
        }
    }
    if {!$nopackages && !$onefile} {
        pkg_mkIndex -direct [pwd] *.xotcl
    }
    if {!$nopackages && !$onefile} {
        my writeScriptFile [file rootname [file tail $configName]].cfmap [IDE::SystemConfigMap asScript]
    }
    my writeScriptFile [my getStartscriptName] [my startScriptString $compToSave]

    my setFileAttributes
    my postGenerate
    IDE::Dialog message "Distribution $configName is generated in $targetDir. Take a look at generated files. Check if all packages are saved. Copy another stuff (tcl-scripts, etc) in this directory."
    my destroy
}
IDE::Deployer instproc changeDir {} {
    my set targetDir [IDE::Dialog getDir [my set targetDir]]
}
IDE::Deployer instproc createSystemMenu {} {
    # no system menu
}
IDE::Deployer instproc getComponentsToDeploy {} {
    set compToSave {}
    if {![IDE::SystemConfigMap exists componentsToLoad] || [IDE::SystemConfigMap set componentsToLoad]==""} {
        if {![IDE::ConfigurationBrowser hasView]} {
            set result [IDE::Dialog yesNo "There are currently no components in configuration map that can be deployed. Do you want to start \"Configuration Map Browser\" and specify them"]
            if {$result} {
                IDE::ConfigurationBrowser showBrowser
            }
        } else {
            IDE::Dialog message "There are currently no components in configuration map that can be deployed. Please specify the components in \"Configuration Map Browser\" first"
        }
        return [list]
    }
    foreach comp [IDE::SystemConfigMap set componentsToLoad] {
        set name [lindex $comp 0]
        set cobj [IDE::Component getCompObjectForNameIfExist $name]
        if {$cobj==""} {
            IDE::Dialog message "$comp is not currently loaded. You can only maka a distribution from loaded components. Operation canceled"
            cd [my set old_dir]
            return
        }
        lappend compToSave $cobj
    }
    return $compToSave
}
IDE::Deployer instproc getStartscriptName {} {
    my set configName
}
IDE::Deployer instproc getTitle {} {
    return {Application Deployer}
}
IDE::Deployer instproc postGenerate {} {
    cd [my set old_dir]
}
IDE::Deployer instproc prepareDirectory {} {
    my instvar targetDir old_dir
    if {![file isdirectory $targetDir]} {
        file mkdir $targetDir
    }
    set old_dir [pwd]
    cd $targetDir
}
IDE::Deployer instproc setFileAttributes {} {
    my instvar configName
    if {![IDE::System isWindowsPlatform]} {
        file attributes $configName -permission rwxr--r--
    }
}
IDE::Deployer instproc setIsXOTclCode {} {
    my instvar isXOTclcode
    if {![IDE::SystemConfigMap exists componentsToLoad]} {
        return
    }
    set isXOTclcode 0
    foreach comp [IDE::SystemConfigMap set componentsToLoad] {
        set name [lindex $comp 0]
        set cobj [IDE::Component getCompObjectForNameIfExist $name]
        if {$cobj!=""} {
            if {[llength [$cobj getObjects]]>0 || [llength [$cobj getClasses]]>0} {
                set isXOTclcode 1
                break
            }
        }
    }
}
IDE::Deployer instproc specificInit {} {
    my instvar win mode className parameter targetDir configName nometa onefile isXOTclcode

    my requireNamespace
    set targetDir [pwd]
    set nometa 1
    set onefile 1
    set isXOTclcode 1

    if {![IDE::SystemConfigMap exists configName]} {
        set configName Start.tcl
    } else {
        set configName [IDE::SystemConfigMap set configName].tcl
    }

    frame $win.buttons -relief raised -border 3
    frame $win.lframe
    frame $win.sframe
    frame $win.tframe

    label $win.infolabel -text "Specify deployments options"

    label $win.ltarget -text "Target Dir"
    label $win.tframe.target -border 2 -width 40 -relief sunken -anchor w -textvariable [self]::targetDir
    button $win.tframe.change -text "Change" -command [list [self] changeDir]
    pack $win.tframe.target  -side left -fill x -expand yes
    pack $win.tframe.change -side left

    label $win.sframe.lab -text "Start File"
    entry $win.sframe.target -textvariable [self]::configName
    pack $win.sframe.lab $win.sframe.target -side left

    checkbutton $win.nometa -text "no meta data @ (metadata need XOTcl)" -variable [self]::nometa
    checkbutton $win.onefile -text "as one file" -variable [self]::onefile
    checkbutton $win.nopackages -text "no packages (use source)" -variable [self]::nopackages
    checkbutton $win.isxotclcode -text "Init XOTcl extension" -variable [self]::isXOTclcode

    button $win.buttons.ok -text Generate -command [list [self] actionGenerate]
    button $win.buttons.cancel -text Cancel -command [list [self] destroy]
    pack $win.buttons.ok $win.buttons.cancel -side left

    pack $win.infolabel -anchor w
    pack $win.ltarget -anchor w
    pack $win.tframe -anchor w -fill x
    pack $win.nometa $win.onefile $win.nopackages $win.isxotclcode -anchor w
    pack $win.sframe -anchor w
    pack $win.buttons -anchor w -ipady 10 -ipadx 6 -fill x

    next

    my setIsXOTclCode
}
IDE::Deployer instproc startScriptInvocation {} {
    my instvar onefile nopackages isXOTclcode
    set script {#!/usr/local/bin/tcl
        # File generated by xotclIDE
        # edit if you want
    }

    if {$isXOTclcode} {
        append script {package require XOTcl
namespace import xotcl::*
}
}

    append script {# we set variable progdir to script location
set sname [info script]
if {$sname==""} {
    # Run interactive for develop purposes
    set progdir [pwd]
} else {
    file lstat $sname stats
    # follow sym links
    if {$stats(type)=="link"} {
        set sname [file readlink $sname]
        if {[file pathtype $sname]=="relative"} {
            set sname [file join [file dirname [info script]] $sname]
        }
    }
    set progdir [file dirname $sname]
}
}
    if {!$nopackages && !$onefile} {
        append script {lappend auto_path [file dirname $progdir]} \n
    }
    return $script
}
IDE::Deployer instproc startScriptString compToSave {
    my instvar onefile nopackages nometa
    if {[IDE::SystemConfigMap exists preStartScript] && [IDE::SystemConfigMap set preStartScript]!=""} {
        append script [IDE::SystemConfigMap set preStartScript] \n
    } else {
        append script [my startScriptInvocation]
    }
    if (!$onefile) {
        if {$nopackages} {
            foreach comp $compToSave {
                append script "source [$comp standardFileName]\n"
            }
        } else {
            foreach comp [IDE::SystemConfigMap set componentsToLoad] {
                append script "package require [lindex $comp 0]\n"
            }
        }
    } else {
        foreach comp $compToSave {
            append script [$comp asScript $nometa] \n
        }
    }
    if {[IDE::SystemConfigMap exists startScript]} {
        append script [IDE::SystemConfigMap set startScript] \n
    }
    return $script
}
IDE::Deployer instproc writeScriptFile {name value} {
    set f [open $name w]
    puts -nonewline $f $value
    close $f
}
IDE::Deployer proc newBrowser {} {
    my instvar browser
    if {![info exists browser] || ![Object isobject $browser]} {
        set browser [my new [Object autoname .deployer]]
    } else {
        IDE::Dialog message "Deployer browser is already open"
    }
}
Class IDE::EditorTranscript -superclass ::IDE::Editor
@ ::IDE::EditorTranscript idemeta component IDEView
IDE::EditorTranscript instproc fileIn {} {
    next
    my instvar fileName
    if {[info exists fileName]} {
        [my info parent] setTitleAddition $fileName
    }
}
IDE::EditorTranscript instproc fileNew {} {
    my instvar fileName
    unset fileName
    my setText {}
}
IDE::EditorTranscript instproc fileOut {} {
    next
    my instvar fileName
    if {[info exists fileName]} {
        [my info parent] setTitleAddition $fileName
    }
}
IDE::EditorTranscript instproc fileSave {} {
    my instvar fileName
    if {![info exists fileName]} {
        my fileOut
    } else {
        my saveFile $fileName
    }
}
IDE::EditorTranscript instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms addCommand {New} [list [self] fileNew] 0 Control-s
    $ms addCommand {Open File} [list [self] fileIn] 0 Control-o
    $ms addCommand {Append File} [list [self] fileAppend] 0 Control-a
    $ms addCommand {Save File} [list [self] fileSave] 0 Control-s
    $ms addCommand {Save File As} [list [self] fileOut] 5
    $ms addSeparator
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Alt-q -name {Do it} -command [list [self] evalSelection] -popdownMenu 1 -enableList isValidTextSelection]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Control-q -name {Print it} -command [list [self] evalDisplaySelection] -popdownMenu 1 -enableList isValidTextSelection]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Alt-x -name {Substitute it} -command [list [self] evalSubstituteSelection] -popdownMenu 1 -enableList isValidTextSelection]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Control-g -name {Inspect it} -command [list [self] evalInspectSelection] -popdownMenu 1 -enableList isValidTextSelection]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Control-r -name {Browse it} -command [list [self] browseSelection] -popdownMenu 1 -enableList isValidTextSelection]
    $ms addMenuItem [::IDE::MenuCommand new -childof $ms -name Find/Replace -command [list IDE::FindReplace bindToView [self]] -popdownMenu 1 -accelerator Alt-f]
}
Class IDE::GlobalVarsInspector -superclass ::IDE::Browser
@ ::IDE::GlobalVarsInspector idemeta component IDEView
IDE::GlobalVarsInspector instproc getTitle {} {
    return "Global Variable Inspector"
}
IDE::GlobalVarsInspector instproc setVarValue {value controller} {
    [self]::varvalue setTextControler $value $controller
}
IDE::GlobalVarsInspector instproc specificInit {} {
    my instvar win

    if {[IDE::System isTkNeverThan84]} {
        panedwindow $win.panedwindow -orient vertical
        IDE::GlobalVarsView [self]::varslist $win.varslist -height 2
        IDE::MethodEdit [self]::varvalue $win.varvalue -width 70 -height 20
        $win.panedwindow add $win.varslist -sticky news -height 180
        $win.panedwindow add $win.varvalue -sticky news -height 200
        pack $win.panedwindow -expand yes -fill both
    } else {
        grid $win.varslist -column 0 -row 0 -sticky news
        grid $win.varvalue -column 0 -row 1 -sticky news
        grid rowconfigure $win 0 -weight 1
        grid rowconfigure $win 1 -weight 2
        grid columnconfigure $win 0 -weight 1
    }
    my initStatusBar 2 2
    [self]::varslist refresh
}
IDE::GlobalVarsInspector proc startBrowser {} {
    my new [Object autoname .importview]
}
@ Class IDE::VarsView {
description {The parent object must understand the messages

[my info parent] setVarValue $value [self]
[my info parent] setStatusBarText $message}
}
Class IDE::VarsView -superclass {::IDE::ListView ::IDE::GUICommands}  -parameter {{label {Object Vars}}}
@ ::IDE::VarsView idemeta categories {initialize user-actions}
@ ::IDE::VarsView idemeta categoriesMethods {{getMenuStruct fillMenuStruct} {inspectAsObjectsList inspectAsObject unsetVariable}}
@ ::IDE::VarsView idemeta component IDEView
IDE::VarsView instproc addToReadTrace actual {
    my instvar vobject vtype
    $vobject requireNamespace
    IDE::VarsTracker addTrace ${vobject}::${actual} read
}
IDE::VarsView instproc addToWatch actual {
    my instvar vobject vtype
    $vobject requireNamespace
    IDE::VarsTracker addTrace ${vobject}::${actual} watch
}
IDE::VarsView instproc addToWriteTrace actual {
    my instvar vobject vtype
    $vobject requireNamespace
    IDE::VarsTracker addTrace ${vobject}::${actual} write
}
IDE::VarsView instproc editSave value {
    my instvar vvariable vtype vobject
    if {$vtype=="array"} {
        my varAction array set $vvariable $value
    } else {
        my varAction set $vvariable $value
    }
}
IDE::VarsView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms addCommand2 {Inspect as Object} [list [self] dispatchWithSelected inspectAsObject] isValidSelection
    $ms addCommand2 {Inspect as Objects List} [list [self] dispatchWithSelected inspectAsObjectsList] isValidSelection
    $ms addCommand2 {Inspect Array} [list [self] dispatchWithSelected inspectArray] {isValidSelection isSelectionArray}
    $ms addCommand2 {Search References} [list [self] dispatchWithSelected searchReferences] isValidSelection
    $ms addSeparator
    $ms addCommand2 {Debug on Read Access} [list [self] dispatchWithSelected addToReadTrace] {isValidSelection isNotSelectionArray}
    $ms addCommand2 {Debug on Write Access} [list [self] dispatchWithSelected addToWriteTrace] {isValidSelection isNotSelectionArray}
    $ms addCommand2 {Watch Variable} [list [self] dispatchWithSelected addToWatch] {isValidSelection isNotSelectionArray}
    $ms addSeparator
    $ms addCommand2 {Unset Variable} [list [self] dispatchWithSelected unsetVariable] isValidSelection
    $ms addCommand2 {Refresh} [list [self] refresh]
    next
}
IDE::VarsView instproc getMenuStruct {} {
    return [IDE::MenuStruct [self]::ms Variables 0]
}
IDE::VarsView instproc inspectArray actual {
    my instvar vobject vtype
    if {$vtype!="array"} {
        IDE::Dialog error "You must select an array"
        return
    }
    IDE::ArrayBrowser inspectArray $vobject $actual
}
IDE::VarsView instproc inspectAsObject actual {
    my instvar vobject vtype
    if {$vtype=="array"} return
    set value [my varAction set $actual]
    if {![Object isobject $value]} {
        IDE::Dialog message "$value is not an Object"
        return
    }
    $value inspect
}
IDE::VarsView instproc inspectAsObjectsList actual {
    my instvar vobject vtype
    if {$vtype=="array"} {
        set value {}
        for {set sid [my varAction array startsearch $actual]} {[my varAction array anymore $actual $sid]} {} {lappend value [my varAction set ${actual}([my varAction array nextelement $actual $sid])]}
        my varAction array donesearch $actual $sid
    } else {
        set value [my varAction set $actual]
    }
    set objects {}
    foreach obj $value {
        if {[Object isobject $obj]} {
            lappend objects $obj
        }
    }
    if {[llength $objects]>0} {
        IDE::ObjectBrowser browseObjectsList $objects
    } else {
        IDE::Dialog message "There are no objects in the list"
    }
}
IDE::VarsView instproc isNotSelectionArray {} {
    expr {[my set vtype]!="array"}
}
IDE::VarsView instproc isSelectionArray {} {
    expr {[my set vtype]=="array"}
}
IDE::VarsView instproc refresh {} {
    my instvar vobject
    my setList [$vobject info vars]
    my selectItem {}
}
IDE::VarsView instproc searchReferences actual {
    my instvar vobject vtype
    if {[$vobject info class]=="::Object"} {
       set sclass $vobject
    } else {
       set sclass [$vobject info class]
    }
    IDE::MethodBrowser searchTextClass $actual $sclass
}
IDE::VarsView instproc selectFor object {
    my instvar vobject
    set vobject $object
    my setList [$object info vars]
    my selectItem {}
}
IDE::VarsView instproc selectItem var {
    my instvar vobject vtype vvariable
    if {$var==""} return
    set message "variable $var"
    set vvariable $var
    if {[my varAction array exists $var]} {
        set value [my varAction array get $var]
        set message "array $var"
        set vtype array
    } elseif {[my varAction info exists $var]} {
        set value [my varAction set $var]
        set vtype string
    } else {
        set value UNKNOWN
        set vtype UNKNOWN
    }
    [my info parent] setVarValue $value [self]
    [my info parent] setStatusBarText $message
}
IDE::VarsView instproc unsetVariable actual {
    my varAction unset $actual
    my refresh
}
IDE::VarsView instproc varAction args {
    [my set vobject] eval $args
}
Class IDE::GlobalVarsView -superclass ::IDE::VarsView  -parameter {{label {Global Vars}}}
@ ::IDE::GlobalVarsView idemeta component IDEView
IDE::GlobalVarsView instproc addToReadTrace actual {
    if {[string range $actual 0 1] ne "::"} {
        set variable ::$actual
    } else {
        set variable $actual
    }
    IDE::VarsTracker addTrace $variable read
}
IDE::GlobalVarsView instproc addToWatch actual {
    if {[string range $actual 0 1] ne "::"} {
        set variable ::$actual
    } else {
        set variable $actual
    }
    IDE::VarsTracker addTrace $variable watch
}
IDE::GlobalVarsView instproc addToWriteTrace actual {
    if {[string range $actual 0 1] ne "::"} {
        set variable ::$actual
    } else {
        set variable $actual
    }
    IDE::VarsTracker addTrace $variable
}
IDE::GlobalVarsView instproc getVariablesInNamespace namespace {
    if {$namespace=="::xotcl"} return
    set res [namespace eval $namespace ::info vars]
    ide::lremoveAll res [info globals]
    set res [ide::lcollect each $res {namespace eval $namespace [list namespace which -variable $each]}]
    foreach chns [namespace children $namespace] {
        if {[Object isobject $chns]} continue
        set res [concat $res [my getVariablesInNamespace $chns]]
    }
    return $res
}
IDE::GlobalVarsView instproc init window {
    next
    my instvar win
    my set treeView 0
    frame $win.fframe
    label $win.fframe.lfilter -text Filter
    entry $win.fframe.efilter
    $win.fframe.efilter insert 0 *
    button $win.fframe.filter -text Refresh -command [list [self] refresh]
    pack $win.fframe.lfilter $win.fframe.efilter $win.fframe.filter -side left
    pack $win.fframe -anchor w
    bind $win.fframe.efilter <Return> [list [self] refresh]
}
IDE::GlobalVarsView instproc inspectArray actual {
    my instvar vtype
    if {$vtype!="array"} {
        IDE::Dialog error "You must select an array"
        return
    }
    IDE::ArrayBrowser inspectGlobalArray $actual
}
IDE::GlobalVarsView instproc refresh {} {
    my instvar win
    set varList [lsort -unique [concat [my getVariablesInNamespace ::] [info globals]]]
    set filter [$win.fframe.efilter get]
    if {$filter!="*" || $filter!=""} {
        set varList [ide::lselect each $varList {[string match $filter $each]}]
    }
    my setList $varList
}
IDE::GlobalVarsView instproc selectFor object {
    error "unproper use. Heritage is dirty"
}
IDE::GlobalVarsView instproc varAction args {
    namespace eval :: $args
}
Class IDE::HeritageBrowser -superclass ::IDE::Browser  -parameter {{vtype heritage}}
@ ::IDE::HeritageBrowser idemeta component IDEView
IDE::HeritageBrowser instproc browse class {
    [self]::hclassview selectFor $class
    my setTitleAddition $class
}
IDE::HeritageBrowser instproc getTitle {} {
    my instvar vtype
    if {$vtype=="heritage"} {
        return {Heritage Browser}
    } else {
        return {Children Browser}
    }
}
IDE::HeritageBrowser instproc initStatusBarWin win {
    my instvar statusBarTextWin
    frame $win
    label $win.label -anchor w
    set statusBarTextWin $win.label
    IDE::StateButtonActivity [self]::stateButton $win.stateBut -states {Source Comment} -command [list [self]::methodedit changeViewType]
    bind [winfo toplevel $win] <Alt-u> [list $win.stateBut invoke]
    pack $win.label  -side left
    pack $win.stateBut -side right
}
IDE::HeritageBrowser instproc specificInit {} {
    my instvar win vtype

    # The simplest factory pattern case in the free world
    if {[IDE::System isDatabase]} {
        set postFix DB
    } else {
        set postFix ""
    }
    if {[IDE::System isTkNeverThan84]} {
        panedwindow $win.panedwindow -orient vertical
        panedwindow $win.upperarea -orient horizontal
        IDE::HeritageClassView [self]::hclassview $win.upperarea.hclassview -vtype $vtype -focusKey {Alt-KeyPress-1} -height 1
        IDE::MethodCategoryView [self]::methodcatview $win.upperarea.methodcatview  -focusKey {Alt-KeyPress-2}  -height 1
        IDE::MethodView${postFix} [self]::methodview $win.upperarea.methodview  -focusKey {Alt-KeyPress-3}  -height 1
        IDE::TclModeEdit [self]::methodedit $win.methodedit

        $win.upperarea add $win.upperarea.hclassview $win.upperarea.methodcatview $win.upperarea.methodview -width 200
        $win.panedwindow add $win.upperarea  $win.methodedit -sticky news -height  220
        pack $win.panedwindow -expand yes -fill both
    } else {
        IDE::HeritageClassView [self]::hclassview $win.hclassview -vtype $vtype -focusKey {Alt-KeyPress-1}
        IDE::MethodCategoryView [self]::methodcatview $win.methodcatview  -focusKey {Alt-KeyPress-2}
        IDE::MethodView${postFix} [self]::methodview $win.methodview  -focusKey {Alt-KeyPress-3}
        IDE::TclModeEdit [self]::methodedit $win.methodedit

        grid $win.hclassview -row 0 -column 0 -sticky news
        grid $win.methodcatview -row 0 -column 1 -sticky news
        grid $win.methodview -row 0 -column 2 -sticky news
        grid $win.methodedit -row 1 -column 0 -columnspan 3 -sticky news

        grid columnconfigure $win 0 -weight 1
        grid columnconfigure $win 1 -weight 1
        grid columnconfigure $win 2 -weight 1
        grid rowconfigure $win 1 -weight 1
    }
    my initStatusBar 2 3
}
IDE::HeritageBrowser proc newBrowser {{tclass {}}} {
    set class $tclass
    if {$class==""} {
        set class [IDE::ClassSelector getClass]
        if {$class==""} return
    }
    set newinst [my new [Object autoname .heritagebrowser]]
    $newinst browse $class
    return $newinst
}
IDE::HeritageBrowser proc newBrowserChild {{tclass {}}} {
    set class $tclass
    if {$class==""} {
        set class [IDE::ClassSelector getClass]
        if {$class==""} return
    }
    set newinst [my create [Object autoname browser] [Object autoname .browser] -vtype children]
    $newinst browse $class
    return $newinst
}
Class IDE::HeritageClassView -superclass {::IDE::AbstractClassView ::IDE::GUICommands ::IDE::FocusPerKey}  -parameter {{label Classes} {vtype heritage}}
@ ::IDE::HeritageClassView idemeta categories user_actions
@ ::IDE::HeritageClassView idemeta categoriesMethods refresh
@ ::IDE::HeritageClassView idemeta component IDEView
IDE::HeritageClassView instproc editSave skript {
    IDE::Dialog message {View can not be used for saving}
}
IDE::HeritageClassView instproc fillMenuStruct ms {
    next
    $ms addCommand Refresh [list [self] refresh]
}
IDE::HeritageClassView instproc getMenuStruct {} {
    return [IDE::MenuStruct [self]::ms Class]
}
IDE::HeritageClassView instproc refresh {} {
    my instvar vclass
    my selectFor $vclass
}
IDE::HeritageClassView instproc selectFor class {
    my instvar hlist vclass vtype
    if {$vtype=="heritage"} {
       my setHList [list [$class getHeritage]]
    } elseif {$vtype=="children"} {
       my setHList [list [$class getChildrenHierarchy]]
    }
    set vclass $class
}
IDE::HeritageClassView instproc selectItem tclass {
    set class [string trimleft $tclass]
    if {[Object isobject [my info parent]::methodcatview]} {
        [my info parent]::methodcatview selectFor $class Classes
    }
    if {$class==""} return
    if {[Object isobject [my info parent]::methodedit]} {
        [my info parent]::methodedit setTextControler [IDE::IntroProxy getObjDef $class] [self]
    }
}
Class IDE::ImportMethodView -superclass ::IDE::Browser  -parameter component
@ ::IDE::ImportMethodView idemeta component IDEView
IDE::ImportMethodView instproc createSystemMenu {} {
  # no system menu
}
IDE::ImportMethodView instproc getTitle {} {
    return "Tcl Procs Import"
}
IDE::ImportMethodView instproc importMethods {} {
    foreach method [[self]::methodlist selectedItem] {
        [my component] importTclProc $method
    }
    my useFilter
}
IDE::ImportMethodView instproc specificInit {} {
    my instvar win hideTclTk

    my requireNamespace
    set hideTclTk 1

    message $win.info -text "With with tool you can import tcl procedures known by interpreter but not registered in XOTclIDE. It can be used by starting XOTclIDE form foreign applicaiton or executing tcl scripts that create procs" -width 450

    IDE::ListView [self]::methodlist $win.mlist -multiselect 1
    entry $win.efilter
    $win.efilter insert 0 *
    button $win.usefilter -text "Use Filter" -command [list [self] useFilter]
    button $win.import -text "Import" -command [list [self] importMethods]
    checkbutton $win.hideTclTk -text "Hide tcl-tk core" -variable [self]::hideTclTk

    grid $win.info -column 0 -row 0
    grid $win.mlist -column 0 -row 1 -columnspan 2 -sticky news
    grid $win.efilter -column 0 -row 2 -sticky w
    grid $win.usefilter -column 1 -row 2 -sticky w
    grid $win.hideTclTk -column 0 -row 3 -sticky w
    grid $win.import -column 0 -row 4 -sticky w
    grid rowconfigure $win 0 -weight 1
    grid columnconfigure $win 0 -weight 1

    my useFilter
}
IDE::ImportMethodView instproc useFilter {} {
    my instvar win hideTclTk
    set filter [$win.efilter get]
    set methods [IDE::TclProcsDescription getAllUnRegisteredMethods]
    if {$filter!="*"} {
        set methods [ide::lselect each $methods {[string match $filter $each]}]
    }
    if {$hideTclTk} {
        foreach pattern {::auto_* ::pkg_* ::tcl* ::tk*} {
            set methods [ide::lselect each $methods {![string match $pattern $each]}]
        }
        ide::lremoveAll methods {bgerror unknown}
    }
    [self]::methodlist setList [lsort -unique $methods]
}
IDE::ImportMethodView proc startBrowserForComponent component {
    my new [Object autoname .importview] -component $component
}
@ Class IDE::MethodBrowser {
description {Method Prowser implements View for all tcl/xotcl Methods
It is used as result view for several method based search function.

The search functions are implemented as class methods}
}
Class IDE::MethodBrowser -superclass ::IDE::Browser
@ ::IDE::MethodBrowser idemeta categoriesMethodsProcs {{emptySearchResult unknown newBrowserList newBrowser} searchImplementorsDialog {searchImplementorsClass searchImplementorsComponent searchSendersAll searchTextAll searchTextComponent searchTextClass searchImplementorsAll} {searchObsoleteCall searchAndConvertObsoleteSelfCall obsoleteMatchList}}
@ ::IDE::MethodBrowser idemeta categoriesProcs {private actions api obsolete}
@ ::IDE::MethodBrowser idemeta component IDEView
IDE::MethodBrowser instproc colorizeSearchString {} {
    my instvar regexpr_string
    if {[info exists regexpr_string] && $regexpr_string!=""} {
        [self]::methodedit colorizeRegExprTextAll $regexpr_string
    }
}
IDE::MethodBrowser instproc initStatusBarWin win {
    my instvar statusBarTextWin
    frame $win
    label $win.label -anchor w
    set statusBarTextWin $win.label
    IDE::StateButtonActivity [self]::stateButton $win.stateBut -states {Source Comment} -command [list [self]::methodedit changeViewType]
    bind [winfo toplevel $win] <Alt-u> [list $win.stateBut invoke]
    pack $win.label  -side left
    pack $win.stateBut -side right
}
IDE::MethodBrowser instproc setMethodList list {
    [self]::methodlist setList $list
    if {[llength $list]==1} {
        [self]::methodlist setSelectedIndex 0 1
    }
}
IDE::MethodBrowser instproc setSearchString re_string {
    my instvar regexpr_string
    set regexpr_string $re_string
}
IDE::MethodBrowser instproc specificInit {} {
    my instvar win

    if {[IDE::System isDatabase]} {
        set postFix DB
    } else {
        set postFix ""
    }

    if {[IDE::System isTkNeverThan84]} {
        panedwindow $win.panedwindow -orient vertical
        IDE::MethodListView${postFix} [self]::methodlist $win.methodlist
        IDE::TclModeEdit [self]::methodedit $win.methodedit -mixin IDE::CodeController
        $win.panedwindow add $win.methodlist -sticky news -height 130
        $win.panedwindow add $win.methodedit -sticky news -height 250
        pack $win.panedwindow -expand yes -fill both
    } else {
        IDE::MethodListView${postFix} [self]::methodlist $win.methodlist
        IDE::TclModeEdit [self]::methodedit $win.methodedit -mixin IDE::CodeController
        grid $win.methodlist -row 0 -column 0 -sticky news
        grid $win.methodedit -row 1 -column 0 -sticky news

        grid columnconfigure $win 0 -weight 1
        grid rowconfigure $win 1 -weight 1
    }
    my initStatusBar 2 1

    bind $win <Alt-n> [list [self]::methodlist selectNextItem]
    bind $win <Alt-p> [list [self]::methodlist selectPrevItem]

    next
}
IDE::MethodBrowser proc checkRegExprWithDialog text {
    if {[catch [list regexp $text sample] ret]} {
        global errorInfo
        IDE::Dialog message "The \"$text\" can not be compiled as regular expresion. Please mask all special characters \[\]\"\.\?().\n Original messege:\n\n$ret"
        return 0
    }
    return 1
}
IDE::MethodBrowser proc emptySearchResult {} {
    IDE::Dialog message {no search result}
}
IDE::MethodBrowser proc newBrowser {} {
    return [my new [Object autoname .methodbrowser]]
}
IDE::MethodBrowser proc newBrowserList {list title} {
    set inst [my newBrowser]
    $inst setMethodList $list
    $inst setTitleAddition $title
    return $inst
}
IDE::MethodBrowser proc obsoleteMatchList {text mlist} {
    foreach item $mlist {
        set expr "(?n)^\s*$item\[\[:>:\]\]"
        if {[regexp $expr $text]} {return 1}
    }
    return 0
}
IDE::MethodBrowser proc searchAndConvertObsoleteSelfCall {} {
    foreach comp [IDE::Component getComponentNames] {
        if {$comp=="core" || $comp=="default"} continue
        if {![string match xdobry::* $comp]} continue
        set cobj [IDE::Component getCompObjectForName $comp]
        foreach class [$cobj getClasses] {
            foreach m [$class info instprocs] {
                set body [$class info instbody $m]
                regsub -all -line {^(\s*)\[self\] } $body {\1my } body2
                # add variables (body2)
                regsub -all -line {\[\[self\] } $body2 {[my } body2
                if {$body!=$body2} {
                    set nb [lreplace [IDE::IntroProxy getBodyInstanceMethod $class $m] 4 4 $body2]
                    namespace eval :: $nb
                }
            }
        }
        foreach object [concat [$cobj getObjects] [$cobj getClasses]] {
        foreach m [$object info procs] {
            set body [$object info body $m]
                regsub -all -line {^(\s*)\[self\] } $body {\1my } body2
                regsub -all -line {\[\[self\] } $body2 {[my } body2
                if {$body!=$body2} {
                    set nb [lreplace [IDE::IntroProxy getBodyClassMethod $object $m] 4 4 $body2]
                    namespace eval :: $nb
                }
            }
        }
    }
}
IDE::MethodBrowser proc searchBreakPoints {} {
    my searchTextAll {([^#]\[self\]|my) halt}
}
IDE::MethodBrowser proc searchClassUsage class {
    if { [string range $class 0 1] == "::" } {
        # remove global namespace prefix which is not always used
        set class [string range $class 2 end]
    }
    my searchTextAll "$class\[\[:>:\]\]"
}
IDE::MethodBrowser proc searchImplementorsAll {implementor {nocomplain 0}} {
    set list {}
    if {[info procs $implementor]!=""} {
        lappend list "proc $implementor"
    }
    if {[info procs ::$implementor]!=""} {
        lappend list "proc ::$implementor"
    }
    foreach obj [IDE::IntroProxy getObjects] {
        if {[$obj info procs $implementor]!=""} {
            lappend list "$obj class>$implementor"
        }
    }
    foreach obj [IDE::IntroProxy getClasses] {
        if {[$obj info procs $implementor]!=""} {
            lappend list "$obj class>$implementor"
        }
        if {[$obj info instprocs $implementor]!=""} {
            lappend list "$obj>$implementor"
        }
    }
    if {$list!={}} {
        my newBrowserList $list $implementor
    } else {
        if {!$nocomplain} {
            my emptySearchResult
        } else {
            return 0
        }
    }
    return 1
}
IDE::MethodBrowser proc searchImplementorsClass {implementor class} {
    set list {}
    if {[Object isclass $class]} {
        foreach obj [concat $class [$class info heritage] [$class getDeepChildren]] {
            if {[$obj info procs $implementor]!=""} {
                lappend list "$obj class>$implementor"
            }
            if {[$obj info instprocs $implementor]!=""} {
                lappend list "$obj>$implementor"
            }
        }
    }

    if {$list!={}} {
        my newBrowserList $list $implementor
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc searchImplementorsComponent {implementor component} {
    set list {}
    set cobj [IDE::Component getCompObjectForNameIfExist $component]
    if {$cobj==""} return
    foreach obj [$cobj getObjects] {
        if {[$obj info procs $implementor]!=""} {
            lappend list "$obj class>$implementor"
        }
    }
    foreach obj [$cobj getClasses] {
        if {[$obj info procs $implementor]!=""} {
            lappend list "$obj class>$implementor"
        }
        if {[$obj info instprocs $implementor]!=""} {
            lappend list "$obj>$implementor"
        }
    }
    if {$list!={}} {
        my newBrowserList $list $implementor
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc searchImplementorsDialog {} {
    set ret [IDE::MethodSelector getMethod]
    if {$ret==""} return
    my searchImplementorsAll $ret
}
IDE::MethodBrowser proc searchObsoleteCall {} {
    set mlist {}
    foreach class [::IDE::IntroProxy getClasses]  {
        if {[string match *IDE* $class]} continue
        set mlist [concat $mlist [$class info instprocs] [$class info procs]]
    }
    foreach class [::IDE::IntroProxy getObjects]  {
        if {[string match *IDE* $class]} continue
        set mlist [concat $mlist [$class info procs]]
    }
    set list {}
    set nlist [lsort -unique $mlist]
    set mlist {}
    foreach method $nlist {
        if {[ide::lcontain [concat [Object info instprocs] info self list next lindex lrange llength] $method]} continue
            lappend mlist $method
        }

    foreach obj [Object info instances] {
        if {[string match *IDE* $obj]} continue
        foreach proc [$obj info procs] {
            if {[my obsoleteMatchList [$obj info body $proc] $mlist]} {
                lappend list "$obj class>$proc"
            }
        }
    }
    foreach obj [Class info instances] {
        if {[string match *IDE* $obj]} continue
        foreach proc [$obj info procs] {
            if {[my obsoleteMatchList [$obj info body $proc] $mlist]} {
                lappend list "$obj class>$proc"
            }
         }
         foreach iproc [$obj info instprocs] {
             if {[my obsoleteMatchList [$obj info instbody $iproc] $mlist]} {
                 lappend list "$obj>$iproc"
             }
         }
    }
    if {$list!={}} {
        set obj [my newBrowserList $list [string range $text 0 15]]
        $obj setSearchString $text
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc searchSendersAll method {
    my searchTextAll \[\[:<:\]\]${method}\[\[:>:\]\] $method
}
IDE::MethodBrowser proc searchTextAll {text {title {}}} {
    if { $title == {} } {
        set title $text
    }
    set list {}
    if {![my checkRegExprWithDialog $text]} return
    # search in registered/managed tcl procs
    foreach proc [IDE::TclProcsDescription getAllRegisteredMethods] {
        if {[regexp -- $text [info body $proc]]} {
            lappend list "proc $proc"
        }
    }
    foreach obj [IDE::IntroProxy getObjects] {
        foreach proc [$obj info procs] {
            if {[regexp -- $text [$obj info body $proc]]} {
                lappend list "$obj class>$proc"
            }
        }
    }
    foreach obj [IDE::IntroProxy getClasses] {
        foreach proc [$obj info procs] {
            if {[regexp -- $text [$obj info body $proc]]} {
                lappend list "$obj class>$proc"
            }
        }
        foreach iproc [$obj info instprocs] {
            if {[regexp -- $text [$obj info instbody $iproc]]} {
                lappend list "$obj>$iproc"
            }
        }
    }
    if {$list!={}} {
        set obj [my newBrowserList $list [string range $title 0 15]]
        $obj setSearchString $text
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc searchTextClass {text class {title {}}} {
    if { $title == {} } {
        set title $text
    }
    set list {}
    if {![my checkRegExprWithDialog $text]} return
    foreach proc [$class info procs] {
        if {[regexp -- $text [$class info body $proc]]} {
            lappend list "$class class>$proc"
        }
    }
    if {[Object isclass $class]} {
        foreach iproc [$class info instprocs] {
            if {[regexp -- $text [$class info instbody $iproc]]} {
                lappend list "$class>$iproc"
            }
        }
    }
    if {$list!={}} {
        set obj [my newBrowserList $list [string range $title 0 15]]
        $obj setSearchString $text
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc searchTextComponent {text component {title {}}} {
    if { $title == {} } {
        set title $text
    }
    set list {}
    if {![my checkRegExprWithDialog $text]} return
    set cobj [IDE::Component getCompObjectForNameIfExist $component]
    if {$cobj==""} return
    foreach pobj [$cobj getProcsGroupsObjects] {
        foreach proc [$pobj getProcsNames] {
            if {[regexp -- $text [info body $proc]]} {
                lappend list "proc $proc"
            }
        }
    }
    foreach obj [$cobj getObjects] {
        foreach proc [$obj info procs] {
            if {[regexp -- $text [$obj info body $proc]]} {
                lappend list "$obj class>$proc"
            }
        }
    }
    foreach obj [$cobj getClasses] {
        foreach proc [$obj info procs] {
            if {[regexp -- $text [$obj info body $proc]]} {
                lappend list "$obj class>$proc"
            }
        }
        foreach iproc [$obj info instprocs] {
            if {[regexp -- $text [$obj info instbody $iproc]]} {
                lappend list "$obj>$iproc"
            }
        }
    }
    if {$list!={}} {
        my newBrowserList $list [string range $title 0 15]
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc unknown args {
    error "unknown method on [self] $args"
}
Class IDE::MethodCategoryView -superclass {::IDE::ListView ::IDE::GUICommands ::IDE::FocusPerKey}  -parameter {{label Categories}}
@ ::IDE::MethodCategoryView idemeta categories {user_actions initialize}
@ ::IDE::MethodCategoryView idemeta categoriesMethods {{newCategory deleteCategory renameCategory} {fillMenuStruct getMenuStruct init}}
@ ::IDE::MethodCategoryView idemeta component IDEView
IDE::MethodCategoryView instproc changeViewType vtype {
    my instvar vclass vobjtype viewtype
    if {$vobjtype=="Tcl Procs"} return
    set viewtype $vtype
    my selectFor $vclass $vobjtype
}
IDE::MethodCategoryView instproc deleteCategory actual {
    my instvar viewtype vclass
    if {$viewtype=="Instance"} {
        $vclass deleteCategory $actual
    } elseif {$viewtype=="Class"} {
        $vclass deleteCategoryB $actual
    }
    my removeItem $actual
    my selectItem {}
}
IDE::MethodCategoryView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms enableList isValidContext

    $ms addCheckButton {All by default} [self]::selectAllByDefault {}
    $ms addCommand2 New [list [self] newCategory]
    $ms addCommand2 Rename [list [self] dispatchWithSelected renameCategory] {isValidSelection}
    $ms addCommand2 Delete [list [self] dispatchWithSelected deleteCategory] {isValidSelection}
    next
}
IDE::MethodCategoryView instproc getMenuStruct {} {
    return [IDE::MenuStruct [self]::ms Category 2]
}
IDE::MethodCategoryView instproc init args {
    my instvar vclass win viewtype vobjtype selectAllByDefault
    next
    ::IDE::StateButton [self]::stateButton $win.stateBut -states {Instance Class} -command [list [self] changeViewType]
    pack $win.stateBut -anchor w
    set vclass {}
    set vobjtype Instances
    set viewtype Instance
    set selectAllByDefault 1
}
IDE::MethodCategoryView instproc isValidContext {} {
    expr {[my exists vclass] && [my set vclass]!=""}
}
IDE::MethodCategoryView instproc newCategory {} {
    my instvar viewtype vclass
    set newname [IDE::IDialogEntry getValue {enter new category name. Consider you can create and assign method to new category in one step. Menu Method->move to category}]
    if {$newname==""} return
    if {[ide::lcontain [my getList] $newname]} {
        IDE::Dialog message "Category $newname already exists!"
        return
    }
    if {$viewtype=="Instance"} {
        $vclass addCategory $newname
    } elseif {$viewtype=="Class"} {
        $vclass addCategoryB $newname
    }
    my addItem $newname
}
IDE::MethodCategoryView instproc renameCategory actual {
    my instvar viewtype vclass
    set newname [::IDE::IDialogEntry getValue {type the new name} $actual]
    if {$newname=="" || $newname==$actual} return
    if {$viewtype=="Instance"} {
        $vclass renameCategory $actual $newname
    } elseif {$viewtype=="Class"} {
        $vclass renameCategoryB $actual $newname
    }
    my renameItem $actual $newname
}
IDE::MethodCategoryView instproc selectFor {class objtype} {
    my instvar vclass win vobjtype viewtype selectAllByDefault
    set vclass $class
    if {$class==""} {
        my resetList
        [my info parent]::methodview selectFor {} {} $viewtype
        return
    }
    if {$objtype=="Tcl Procs"} {
        my resetList
        [my info parent]::methodview selectFor $class {} $objtype
        set vobjtype $objtype
        return
    }
    if {$vobjtype!=$objtype} {
        if {$objtype=="Objects"} {
            [self]::stateButton setStates {Class}
        } else {
            [self]::stateButton setStates {Instance Class}
        }
        set viewtype [[self]::stateButton state]
        set vobjtype $objtype
    }
    if {$viewtype=="Instance"} {
        my setList [IDE::IntroProxy getCategoriesForClass $class]
    } elseif {$viewtype=="Class"} {
        my setList [IDE::IntroProxy getCategoriesForObject $class]
    }
    if {$selectAllByDefault} {
        my setSelectedItem _all_categories
    } else {
        my selectItem {}
    }
}
IDE::MethodCategoryView instproc selectItem cat {
    my instvar vclass viewtype
    if {[Object isobject [my info parent]::methodview]} {
        [my info parent]::methodview selectFor $vclass $cat $viewtype
    }
}
Class IDE::MethodEdit -superclass ::IDE::Editor
@ ::IDE::MethodEdit idemeta component IDEView
IDE::MethodEdit instproc changeViewType type {
    my instvar vtype controler
    set vtype $type
    if {[my exists controler] && [Object isobject $controler]} {
        $controler refreshView
    }
}
IDE::MethodEdit instproc fillMenuStruct ms {
    next
    $ms addMenuItem [IDE::MenuSeparator new -childof $ms -popdownMenu 1]
    #$ms addCommand Revert "[self] revert"
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Control-s -name Save/Accept -command [list [self] save] -popdownMenu 1]
}
IDE::MethodEdit instproc haveNoChanges {} {
    if {![my exists oldtext]} {return 0}
    expr {[my set oldtext]==[my getText]}
}
IDE::MethodEdit instproc ignoreNoChanges {} {
    my instvar oldtext
    set oldtext -
}
IDE::MethodEdit instproc init args {
    my set vtype Source
    next
}
IDE::MethodEdit instproc save {} {
    if {![my exists oldtext]} return
    set newtext [my getText]
    if {[IDE::System isTkNeverThan84]} {
        if {[[my getTextWindow] edit modified]} {
            my saveValue $newtext
       }
    } else {
        if {[my set oldtext]!=$newtext} {
            my saveValue $newtext
        }
    }
}
IDE::MethodEdit instproc saveForce {} {
    if {![my exists oldtext]} return
    set newtext [my getText]
    if {[my set oldtext]!=$newtext} {
        # !!! no handlung of comments
        [my set controler] editSave $newtext
    }
}
IDE::MethodEdit instproc saveSource value {
    [my set controler] editSave $value
}
IDE::MethodEdit instproc saveValue value {
    my instvar controler vtype
    if {$vtype=="Source"} {
        my saveSource $value
    } elseif {$vtype eq "Comment"} {
        $controler editSaveComment $value
    } else {
        error {unknown view type}
    }
}
IDE::MethodEdit instproc setBodyTextControler {tvclass tvtype tmethod controler} {
    my set vclass $tvclass
    my set vctype $tvtype
    my set method $tmethod
    set ret {}
    if {$tvtype=="Tcl Procs"} {
        if {[Object isobject $tvclass]} {
            set pobj [$tvclass getProcObjForNameIfExist $tmethod]
            if {$pobj!=""} {
                set ret [$pobj getBody]
            }
        }
    } else {
        set ret [IDE::IntroProxy getBody${tvtype}MethodIfExist $tvclass $tmethod]
    }
    if {$ret==""} {
        my setTextControler "# Method $tmethod in $tvclass was probably deleted from the System" $controler
    }
    my setTextControler $ret $controler xotcl
}
IDE::MethodEdit instproc setTextControler {text contr {type none}} {
    my instvar win state controler oldtext
    set oldtext $text
    set controler $contr
    set state use
    if {$type=="none" && [$contr istype IDE::MethodView]} {
        set type xotcl
    }
    my setTypedText $text $type
}
IDE::MethodEdit instproc setTextTypeControler {text type contr} {
    my instvar win state controler oldtext
    set oldtext $text
    set controler $contr
    set state use
    my setTypedText $text $type
}
Class IDE::MethodListView -superclass {::IDE::ListView ::IDE::GUICommands}
@ ::IDE::MethodListView idemeta component IDEView
IDE::MethodListView instproc browseChildren actual {
     set item [split $actual >]
     set vclass [lindex [lindex $item 0] 0]
     if {[Object isclass $vclass]} {
         IDE::HeritageBrowser newBrowserChild $vclass
     } else {
         my upsMessage "$vclass is not a class"
     }
}
IDE::MethodListView instproc browseHeritage actual {
    set item [split $actual >]
    set vclass [lindex [lindex $item 0] 0]
    if {[Object isclass $vclass]} {
        IDE::HeritageBrowser newBrowser $vclass
    } else {
        my upsMessage "$vclass is not a class"
    }
}
IDE::MethodListView instproc editSave skript {
    namespace  eval :: $skript
}
IDE::MethodListView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms addCommand2 {Remove form List} [list [self] dispatchWithSelected removeMethod] isValidSelection
    $ms addCommand2 {Heritage Browser} [list [self] dispatchWithSelected browseHeritage] isValidSelection
    $ms addCommand2 {Children Browser} [list [self] dispatchWithSelected browseChildren] isValidSelection
    $ms addCommand2 {Search Senders} [list [self] dispatchWithSelected searchSenders] isValidSelection
    $ms addCommand2 {Search Implementors} [list [self] dispatchWithSelected searchImplementors] isValidSelection
    my menuInsertions $ms
    next
}
IDE::MethodListView instproc getMenuStruct {} {
    return [IDE::MenuStruct create [self]::ms Methods 0]
}
IDE::MethodListView instproc removeMethod actual {
    my removeItem $actual
}
IDE::MethodListView instproc searchImplementors actual {
    set method [lindex [split $actual >] 1]
    IDE::MethodBrowser searchImplementorsAll $method
}
IDE::MethodListView instproc searchSenders actual {
    set method [lindex [split $actual >] 1]
    IDE::MethodBrowser searchSendersAll $method
}
IDE::MethodListView instproc selectClassTypeMethod {class type method} {
    [my info parent]::methodedit setBodyText $class $type $method
}
IDE::MethodListView instproc selectItem item {
    if {$item==""} return
    if {[lindex $item 0]=="proc"} {
        set method [lindex $item 1]
        set type "Tcl Procs"
        set class [IDE::TclProcsDescription getMethodFor $method]
        if {$class!=""} {
            set class [$class getGroupObj]
        }
    } else {
        set item [split $item >]
        set method [lindex $item 1]
        set type [lindex [lindex $item 0] 1]
        if {$type==""} { set type Instance} else { set type Class}
        set class [string trimleft [lindex [lindex $item 0] 0] :]
    }
    my selectClassTypeMethod $class $type $method
    [my info parent] colorizeSearchString
}
Class IDE::MethodSelector
@ ::IDE::MethodSelector idemeta component IDEView
IDE::MethodSelector proc getMethod {} {
    IDE::IDialogEntry [self]::classentry -message {Give method name or glob patern} -entry *
    if {[[self]::classentry prompt]!="ok"} {
        [self]::classentry destroy
        return {}
    }
    set result [[self]::classentry entry]
    [self]::classentry destroy
    if {![regexp -- {\*} $result]} {
        return $result
    }
    set mlist [my getMethodsForPattern $result]
    if {[llength $mlist]==0} {
        return {}
    }
    IDE::IDialogList [self]::classlist -message {Choose the class} -list [lsort -unique $mlist]
    if {[[self]::classlist prompt]!="ok"} {
        [self]::classlist destroy
        return {}
    }
    set result [[self]::classlist selectedItem]
    [self]::classlist destroy
    return $result

}
IDE::MethodSelector proc getMethodsForPattern patern {
    set mlist {}
    foreach class [::IDE::IntroProxy getClasses]  {
        set mlist [concat $mlist [$class info instprocs $patern] [$class info procs $patern]]
    }
    foreach class [IDE::IntroProxy getObjects] {
        set mlist [concat $mlist [$class info procs $patern]]
    }

    return $mlist
}
Class IDE::MethodView -superclass {::IDE::ListView ::IDE::GUICommands ::IDE::FocusPerKey}  -parameter {{label Methods}}
@ ::IDE::MethodView idemeta categories {interface initialize user_actions special_actions handle-editing private search selectionstate}
@ ::IDE::MethodView idemeta categoriesMethods {{handleScript selectFor selectItem editSave} {getMenuStruct fillMenuStruct init} {closeAllSpawned moveToCategory backMethod forwardMethod deleteMethod invokeProcs convertProcToMethod newMethodTemplate newInitializeAfterLoad newOverwriteMethodTemplate} {spawnMethodUnderCursor viewMethodUnderCursor insertMethodToEdit spawnMethod selectionToMethod} {editSaveComment refreshActual checkItem syntaxCheck getEditText selectHItem selectHItemRefresh refreshView} getComponentInContext {searchImplementors searchText searchSenders} {isValidContext isSelectionProc isSelectionTclProc}}
@ ::IDE::MethodView idemeta component IDEView
IDE::MethodView instproc backMethod {} {
    my instvar history historyIndex
    while {$historyIndex>=1} {
        incr historyIndex -1
        set hitem [lindex $history $historyIndex]
        if {[my checkItem $hitem]} {
            my selectHItemRefresh $hitem
            break
        }
        set history [lreplace $history $historyIndex $historyIndex]
    }
}
IDE::MethodView instproc changeInheritedMethodView {} {
    my instvar vclass vtype vcategories
    my selectFor $vclass $vcategories $vtype
}
IDE::MethodView instproc checkItem hitem {
    foreach {vclass vtype method} $hitem {}
    if {![Object isobject $vclass]} {return 1}
    switch $vtype {
        proc {
            if {[$vclass info procs $method]==""} {return 0}
        }
        instproc  {
            if {[$vclass info procs $method]==""} {return 0}
        }
        {Tcl Procs} {
            if {[info procs $method]==""} {return 0}
        }
    }
    return 1
}
IDE::MethodView instproc closeAllSpawned {} {
    foreach obj [my info children] {
        if {[$obj istype IDE::SpawnMethodEdit]} {
            $obj destroy
        }
    }
}
IDE::MethodView instproc convertProcToMethod procs {
    IDE::ProcToMethodWizzard convertProcedures $procs
}
IDE::MethodView instproc deleteMethod method {
    my instvar vtype vclass
    if {$vtype=="Instance"} {
        $vclass instproc $method {} {}
        $vclass uncategoryFor $method
    } elseif {$vtype=="Class"} {
        $vclass proc $method {} {}
        $vclass uncategoryForB $method
    } elseif {$vtype=="Tcl Procs"} {
        $vclass deleteMethod $method
    }
    my selectItem {}
    my removeItem $method
}
IDE::MethodView instproc editSave skript {
   my instvar vtype vclass actItem history historyIndex vcategories
   if {![info complete $skript]} {
       IDE::Dialog message {This is not complete Tcl-Script. Check the paratness}
       return
   }
   if {$vtype eq "Tcl Procs" && [lindex $skript 0] eq "proc"} {
       set procname [$vclass handleScript $skript]
   } else {
       namespace  eval :: $skript
   }
   set nclass [lindex $skript 0]
   set ntype [lindex $skript 1]
   set nmethod [lindex $skript 2]
   if {[info exists actItem] && $actItem!=""} {
       foreach {oclass otype omethod} $actItem {}
   } else {
       set oclass $vclass
       set omethod {}
       set otype $vtype
   }
   if {$nclass eq "proc"} {
       if {$nmethod eq $omethod} {
           return
       } else {
           if {$otype eq "Tcl Procs" && $procname ne ""} {
               set hitem [list $oclass $otype $procname]
               my addItem $procname
               my setSelectedItem $procname 0
           } else {
               return
           }
       }
   } else {
       if {$ntype eq "instproc"} {
           set ntype Instance
       } else {
           set ntype Class
       }
       if {$nmethod eq $omethod && $ntype eq $otype && $nclass eq $oclass} {
           return
       } else {
           set hitem [list $nclass $ntype $nmethod]
           if {$ntype eq $vtype && $nclass eq $vclass && ($vcategories eq "_all_categories" || $vcategories eq "_uncategorized")} {
               my addItem $nmethod
               my setSelectedItem $nmethod 0
           }
       }
   }
    incr historyIndex
    set history [linsert $history $historyIndex $hitem]
}
IDE::MethodView instproc editSaveComment comment {
    my instvar actItem
    set vclass [lindex $actItem 0]
    set vtype [lindex $actItem 1]
    set method [lindex $actItem 2]
    $vclass setMethodComment $vtype $method $comment
}
IDE::MethodView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms enableList isValidContext

    [$ms addCommand {Back Method} [list [self] backMethod] {} {Alt-Left}] enableList noglobal
    [$ms addCommand {Forward Method} [list [self] forwardMethod] {} {Alt-Right}] enableList noglobal
    $ms addCommand {View Method under Cursor} [list [self] viewMethodUnderCursor] {} {Control-m}
    $ms addCommand {Spawn View} [list [self] spawnMethod]
    $ms addCommand {Spawn Method under Cursor} [list [self] spawnMethodUnderCursor] {} {Control-n}
    $ms addCommand {Selection to new method} [list [self] selectionToMethod]
    $ms addCommand {Close All Spawned} [list [self] closeAllSpawned]
    $ms addCheckButton {Show Inherited Methods} [self]::inheritedMethod [list [self] changeInheritedMethodView]
    $ms addSeparator
    $ms addCommand2 Delete [list [self] dispatchWithSelectedMulti deleteMethod] isValidSelection
    $ms addSeparator
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name {New Method Template} -command [list [self] newMethodTemplate] -popdownMenu 1 -accelerator {Control-k}]
    $ms addCommand2 {New Overwrite Method Template} [list [self] newOverwriteMethodTemplate]
    $ms addCommand2 {New initializeAfterLoad} [list [self] newInitializeAfterLoad]
    $ms addCommand3 {Convert To XOTcl-Method} [list [self] dispatchWithSelectedAll convertProcToMethod] isSelectionTclProc
    $ms addSeparator

    IDE::MenuStruct ${ms}::searchText {Search Text} -popdownMenu 1
    $ms addCascadeMenu ${ms}::searchText
    ${ms}::searchText addCommand2 {Local} [list [self] searchText local] noglobal
    ${ms}::searchText addCommand2 {In Component} [list [self] searchText component] noglobal
    ${ms}::searchText addMenuItem [IDE::MenuCommand new -childof ${ms}::searchText -name All -command [list [self] searchText all] -popdownMenu 1 -enableList noglobal -accelerator F4]

    IDE::MenuStruct ${ms}::searchImplementors {Search Implementors} -popdownMenu 1
    $ms addCascadeMenu ${ms}::searchImplementors
    ${ms}::searchImplementors addCommand2 {Local} [list [self] searchImplementors local] isValidSelection
    ${ms}::searchImplementors addCommand2 {In Component} [list [self] searchImplementors component] isValidSelection
    ${ms}::searchImplementors addCommand2 {All} [list [self] searchImplementors all] isValidSelection
    IDE::MenuStruct ${ms}::searchSenders {Search Senders} -popdownMenu 1
    $ms addCascadeMenu ${ms}::searchSenders
    ${ms}::searchSenders addCommand2 {Local} [list [self] searchSenders local] isValidSelection
    ${ms}::searchSenders addCommand2 {In Component} [list [self] searchSenders component] isValidSelection
    ${ms}::searchSenders addCommand2 {All} [list [self] searchSenders all] isValidSelection

    my menuInsertions $ms
    $ms addSeparator
    $ms addCommand2 {Invoke Procs} [list [self] dispatchWithSelected invokeProcs] [list isValidSelection isSelectionProc]
    $ms addCommand2 {Change Category} [list [self] dispatchWithSelectedAll moveToCategory] isValidSelection
    next
}
IDE::MethodView instproc forwardMethod {} {
    my instvar history historyIndex
    while {$historyIndex<[expr {[llength $history]-1}]} {
        incr historyIndex 1
        set hitem [lindex $history $historyIndex]
        if {[my checkItem $hitem]} {
            my selectHItemRefresh $hitem
            break
        }
        set history [lreplace $history $historyIndex $historyIndex]
    }
}
IDE::MethodView instproc getComponentInContext {} {
    if {[Object isobject [my info parent]::appview]} {
        return [[my info parent]::appview selectedItem]
    } else {
        return [[my set vclass] getComponentName]
    }
}
IDE::MethodView instproc getEditText hitem {
    set vclass [lindex $hitem 0]
    set vtype [lindex $hitem 1]
    set method [lindex $hitem 2]
    set ret {}
    if {$vtype=="Tcl Procs"} {
        if {[Object isobject $vclass]} {
            set pobj [$vclass getProcObjForNameIfExist $method]
            if {$pobj!=""} {
                set ret [$pobj getBody]
            }
        }
    } else {
        set ret [IDE::IntroProxy getBody${vtype}MethodIfExist $vclass $method]
    }
    if {$ret==""} {
        return "# Method $method in $vclass was probably deleted from the System"
    }
    return $ret
}
IDE::MethodView instproc getMenuStruct {} {
    return [IDE::MenuStruct [self]::ms Method 0]
}
IDE::MethodView instproc handleScript script {
    # only used by child classes
}
IDE::MethodView instproc init args {
    my instvar vclass win history historyIndex vtype inheritedMethod
    # saveEdit need vtype
    set vtype Instance
    set history {}
    set historyIndex -1
    set vclass {}
    set inheritedMethod 0
    next
    bind $win.listbox <2> [list [self] insertMethodToEdit %y]
    bind $win.listbox <Insert> [list [self] newMethodTemplate]
}
IDE::MethodView instproc insertMethodToEdit y {
    my instvar win listItems
    [my info parent]::methodedit appendToCursor "[lindex $listItems [$win.listbox nearest $y]] "
}
IDE::MethodView instproc invokeProcs actual {
    my instvar vclass vtype
    if {$vtype=="Class"} {
        IDE::System invokeProc $vclass $actual
    } elseif {$vtype=="Tcl Procs"} {
        IDE::System invokeTclProc $actual
    }
}
IDE::MethodView instproc isSelectionProc {} {
    expr {[my set vtype]=="Class" || [my set vtype]=="Tcl Procs"}
}
IDE::MethodView instproc isSelectionTclProc {} {
    expr {[string equal [my set vtype] "Tcl Procs"]}
}
IDE::MethodView instproc isValidContext {} {
    expr {[my exists vclass] && [my set vclass]!=""}
}
IDE::MethodView instproc moveToCategory methods {
    my instvar vclass vcategories vtype
    IDE::IDialogListEntry [self]::dialog -message {Choose the category or name the new one}  -list [[my info parent]::methodcatview set listItems]
    if {[[self]::dialog prompt]=="ok"} {
        set cat [[self]::dialog getvalue]
        if {$cat!=""} {
            if {$vcategories!=$cat} {
                foreach method $methods {
                    if {$vtype=="Instance"} {
                         $vclass moveToCategory $method $cat
                    } else {
                         $vclass moveToCategoryB $method $cat
                    }
                    if {$vcategories!="_all_categories"} {
                        my removeItem $method
                    }
                }
                [my info parent]::methodcatview addItem $cat
            }
        }
    }
    [self]::dialog destroy
}
IDE::MethodView instproc newInitializeAfterLoad {} {
    my instvar vclass
    [my info parent]::methodedit setTextControler "$vclass proc initializeAfterLoad {} {\n    # init your class varibales and other stuff\n}" [self]
    [my info parent]::methodedit setSelection "2.4" "2.4 lineend"
    my prepareNewMethodState
}
IDE::MethodView instproc newMethodTemplate {} {
    my instvar vclass vtype
    if {[Object isclass $vclass] && $vtype=="Instance"} {
        set proc instproc
    } else {
        set proc proc
    }
    set procName [[my info parent]::methodedit getSelection]
    if {![regexp -- {\w+} $procName]} {
        set procName procName
    }
    if {$vtype=="Tcl Procs"} {
        if {[$vclass withNamespace]} {
            set pre [$vclass getObjectName]::
        } else {
            set pre {}
        }
        set text "proc ${pre}$procName {args} {\n    # enter the body hier\n}\n"
        set start [string length "proc ${pre}"]
    } else {
        set text "$vclass $proc $procName {args} {\n    # enter the body hier\n}\n"
        set start [string length "$vclass $proc "]
    }
    [my info parent]::methodedit setTextControler $text [self]
    if { $procName eq "procName" } {
        set stop [expr {$start + [string length $procName]}]
        [my info parent]::methodedit setSelection "1.0 + $start chars" "1.0 + $stop chars"
    } else {
        [my info parent]::methodedit setSelection "2.4" "2.4 lineend"
    }
    my prepareNewMethodState
}
IDE::MethodView instproc newOverwriteMethodTemplate {} {
    my instvar vclass
    if {![Object isclass $vclass]} {
        my upsMessage "$vclass is not a class"
        return
    }
    set methods [list]
    foreach c [$vclass info heritage] {
        if {$c eq "::xotcl::Object"} continue
        set methods [concat $methods [$c getAllInstMethods ::xotcl::Object]]
    }
    set methods [lsort -unique $methods]
    ide::lremoveAll methods [$vclass info instprocs]
    if {$methods==""} {
        IDE::Dialog message "Nothing to overwrite"
        return
    }
    set procName [IDE::IDialogList getListItem {Select method to overwrite} $methods]
    set args {}
    foreach c [$vclass info heritage] {
        if {[ide::lcontain [$c info instprocs] $procName]} {
            set args [list [$c info instargs $procName]]
            break
        }
    }
    if {$procName==""} return
    [my info parent]::methodedit setTextControler "$vclass instproc $procName $args {\n    # enter the body hier\n}\n" [self]
    [my info parent]::methodedit setSelection "2.4" "2.4 lineend"
    my prepareNewMethodState
}
IDE::MethodView instproc prepareNewMethodState {} {
    my unselect
    [my info parent]::methodedit focus
    # We want to change state to Source but do not provoke events
    # quite dirty
    [my info parent]::methodedit set vtype Source
    set sb [my info parent]::stateButton
    if {[Object isobject $sb]} {
        $sb setActivity 0
        $sb changeStateTo Source 0
    }
}
IDE::MethodView instproc refreshActual {} {
    my instvar history historyIndex
    my selectHItem [lindex $history $historyIndex]
}
IDE::MethodView instproc refreshView {} {
    my instvar actItem
    if {$actItem==""} return
    set v [my info parent]::methodedit
    set vtclass [lindex $actItem 0]
    set vtype [lindex $actItem 1]
    set method [lindex $actItem 2]
    if {[$v set vtype] eq "Comment"} {
        set comment [$vtclass getMethodComment $vtype $method]
        [my info parent]::methodedit setTextControler $comment [self]
    } elseif {[$v set vtype] eq "Source"} {
        my selectHItem $actItem
        set sb [my info parent]::stateButton
        if {[Object isobject $sb]} {
            set hasComment [$vtclass hasMethodComment $vtype $method]
            $sb  setActivity $hasComment
        }
    } else {
        error {Unknown view type}
    }
}
IDE::MethodView instproc searchImplementors range {
    my instvar vclass
    set implementor [my selectedItemFirst]
    if {$implementor!=""} {
        switch -- $range {
            local {IDE::MethodBrowser searchImplementorsClass $implementor $vclass}
            component {
                IDE::MethodBrowser searchImplementorsComponent $implementor [my getComponentInContext]
            }
            all {IDE::MethodBrowser searchImplementorsAll $implementor}
        }
    }
}
IDE::MethodView instproc searchSenders range {
    my instvar vclass
    set text [my selectedItemFirst]
    if {$text!=""} {
        set pattern \[\[:<:\]\]${text}\[\[:>:\]\]
        switch -- $range {
            local {IDE::MethodBrowser searchTextClass $pattern $vclass $text}
            component {
                IDE::MethodBrowser searchTextComponent $pattern [my getComponentInContext] $text
            }
            all {IDE::MethodBrowser searchTextAll $pattern $text}
        }
    }
}
IDE::MethodView instproc searchText range {
    my instvar vclass
    set sel [[my info parent]::methodedit getSelection]
    set text [IDE::IDialogEntry getValue {give search text (regular expresion)} $sel]
    if {$text!=""} {
        switch $range {
            local {IDE::MethodBrowser searchTextClass $text $vclass}
            component {
                IDE::MethodBrowser searchTextComponent $text [my getComponentInContext]
            }
            all {IDE::MethodBrowser searchTextAll $text}
        }
    }
}
IDE::MethodView instproc selectFor {class categories type} {
    my instvar vclass vtype vcategories inheritedMethod
    if {$class==""} {
        my resetList
        set vclass {}
    } elseif {$type=="Tcl Procs"} {
        set cobj [[my info parent] getActualComponentObject]
        set vclass [$cobj getProcsGroupWithName $class]
        if {$vclass==""} return
        my setList [$vclass getProcsNames]
    } else {
        if {$categories==""} {
            set vclass {}
            my resetList
        } else {
            if {$inheritedMethod && $type eq "Instance"} {
                set inheritedMethods [list]
                set ownMethods [IDE::IntroProxy getInstanceMethods $class $categories]
                foreach c [lrange [$class info heritage] 0 end-1] {
                    foreach m [IDE::IntroProxy getInstanceMethods $c $categories] {
                        if {[lsearch $ownMethods $m]!=-1 || [lsearch $inheritedMethods $m]!=-1} continue
                        lappend inheritedMethods $m
                    }
                }
                set allMethods [lsort [concat $ownMethods $inheritedMethods]]
                my setListUnsorted $allMethods
                foreach m $inheritedMethods {
                    my markItemIndexForeGround [lsearch $allMethods $m] blue
                }
            } else {
                my setList [IDE::IntroProxy get${type}Methods $class $categories]
            }
            set vclass $class
        }
    }
    set vtype $type
    set vcategories $categories
    my selectItem {}
}
IDE::MethodView instproc selectHItem hitem {
    [my info parent]::methodedit setBodyTextControler [lindex $hitem 0] [lindex $hitem 1] [lindex $hitem 2] [self]
}
IDE::MethodView instproc selectHItemRefresh hitem {
    set parent [my info parent]
    if {$parent!="" && [$parent info methods refreshHItem]!=""} {
        $parent refreshHItem $hitem
    }
    my set actItem $hitem
    my refreshView
    my setSelectedItem [lindex $hitem end] 0
}
IDE::MethodView instproc selectItem method {
    my instvar vclass vtype history historyIndex actItem inheritedMethod
    set actItem {}
    if {$method==""} {
        [my info parent]::methodedit setTextControler {} [self]
        return
    }
    if {$inheritedMethod && $vtype eq "Instance"} {
        foreach c [concat $vclass [$vclass info heritage]] {
            if {[$c info instprocs $method]!=""} {
                set actItem [list $c $vtype $method]
                break
            }
        }
    } else {
        set actItem [list $vclass $vtype $method]
    }
    if {[lindex $history $historyIndex]!=$actItem} {
        incr historyIndex
        set history [linsert $history $historyIndex $actItem]
    }
    my refreshView
}
IDE::MethodView instproc selectionToMethod {} {
    my instvar vclass vtype
    set selection [[my info parent]::methodedit getSelection]
    if {$selection!=""} {
        if {$vtype=="Instance"} {
            set pname instproc
        } else {
            set pname proc
        }
        set text "$vclass $pname yourProcName {} {\n$selection\n}"
        set obj [IDE::SpawnMethodEdit new -childof [self] [Object autoname .spawnedmethod]]
        ${obj}::methodedit setTextControler $text [self]
        my prepareNewMethodState
    }
}
IDE::MethodView instproc spawnMethod {} {
    set text [[my info parent]::methodedit getText]
    if {$text!=""} {
        set obj [IDE::SpawnMethodEdit new -childof [self] [Object autoname .spawnedmethod]]
        ${obj}::methodedit setTextControler $text [self]
        ${obj}::methodedit ignoreNoChanges
        # The script can be not proper tcl list
        catch {$obj setTitleAddition "[lindex $text 0]>>[lindex $text 2]"}
    }
}
IDE::MethodView instproc spawnMethodUnderCursor {} {
    my instvar vclass vtype
    set word [[my info parent]::methodedit getWordUnderCursor]
    set sclass $vclass
    set stype $vtype
    set smethod {}
    #[self] halt
    if {[regexp -- {[a-zA-Z]\w+} $word]} {
        if {$stype=="Instance"} {
            if {[$sclass info instprocs $word]!=""} {
                set smethod $word
            } else {
                foreach pair [$vclass getAllFullInstMethods] {
                    if {[lindex $pair 1]==$word} {
                        set sclass [lindex $pair 0]
                        set smethod $word
                    }
                }
            }
        } elseif {$stype=="Class"} {
            if {[$sclass info procs $word]!=""} {
                set smethod $word
            }
        }
    }
    if {$smethod!=""} {
        set obj [IDE::SpawnMethodEdit new -childof [self] [Object autoname .spawnedmethod]]
        ${obj}::methodedit setTextControler [my getEditText [list $sclass $stype $smethod]] [self]
    }
}
IDE::MethodView instproc syntaxCheck {text editor} {
    set context [PrsContext new -volatile]
    $context parseAndCheck $text
    if {[$context hasErrors]} {
        IDE::SyntaxErrorView new -errors [$context errors] -editor $editor -init [Object autoname .syntaxview]
        return 0
    } else {
        return 1
    }
}
IDE::MethodView instproc viewMethodUnderCursor {} {
    my instvar vclass vtype
    set word [[my info parent]::methodedit getWordUnderCursor]
    #[self] halt
    if {[regexp -- {[a-zA-Z]\w+} $word]} {
        if {$vtype=="Instance"} {
            if {[$vclass info instprocs $word]!=""} {
                my selectItem $word
            } else {
                foreach pair [$vclass getAllFullInstMethods] {
                    if {[lindex $pair 1]==$word} {
                        set vclass [lindex $pair 0]
                        my selectItem $word
                    }
                }
            }
        } elseif {$vtype=="Class"} {
            if {[$vclass info procs $word]!=""} {
                my selectItem $word
            }
        }
    }
}
Class IDE::ObjectBrowser -superclass {::IDE::Browser ::IDE::GUICommands}  -parameter {{type single} {atHead 1}}
@ ::IDE::ObjectBrowser idemeta categories {private initialize actions}
@ ::IDE::ObjectBrowser idemeta categoriesMethods {{setViewList save setViewObject} {getMenuStruct specificInit fillMenuStruct} {browseClass trackObject printFilters printString printSelf browseMixins inspectParent destroyActual}}
@ ::IDE::ObjectBrowser idemeta component IDEView
IDE::ObjectBrowser instproc browseClass args {
    my instvar vobject
    if {[$vobject info class]!="::xotcl::Object"} {
        IDE::HeritageBrowser newBrowser [$vobject info class]
    }
}
IDE::ObjectBrowser instproc browseMixins {} {
    my instvar vobject

    set listchooser [IDE::IDialogListOrderChooser new -volatile -message "Mixin Classes for $vobject" -listout [$vobject info mixin] -listin [IDE::IntroProxy getClasses]]

    set ret [$listchooser prompt]
    if {$ret!="cancel"} {
        $vobject mixin [$listchooser set listout]
    }
}
IDE::ObjectBrowser instproc destroyActual {} {
    my instvar vobject type
    if {[IDE::Dialog yesNo "Do you want to destroy $vobject?"]!="yes"} {
        return
    }
    $vobject destroy
    if {$type=="list"} {
        [self]::objectsview removeItem $vobject
    } else {
        my destroy
    }
}
IDE::ObjectBrowser instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms addCommand Destroy [list [self] destroyActual]
    $ms addCommand {Track Object} [list [self] trackObject]
    $ms addCommand {Browse Class} [list [self] browseClass]
    $ms addCommand {Browse Mixins} [list [self] browseMixins]
    $ms addCommand {Print Self} [list [self] printSelf]
    $ms addCommand {Print printString} [list [self] printString]
    $ms addCommand {Print Filters} [list [self] printFilters]
}
IDE::ObjectBrowser instproc getMenuStruct {} {
    return [IDE::MenuStruct [self]::ms Object 0]
}
IDE::ObjectBrowser instproc getTitle {} {
    return "Object Inspector"
}
IDE::ObjectBrowser instproc inspectParent {} {
    my instvar vobject
    if {[set parent [$vobject info parent]]!="::" && [Object isobject $parent]} {
        my setViewObject $parent
    } else {
        IDE::Dialog message "$vobject has no parent"
    }
}
IDE::ObjectBrowser instproc printFilters {} {
    [self]::methodedit setTextControler [[my set vobject] info filter] [self]
}
IDE::ObjectBrowser instproc printSelf {} {
    [self]::methodedit setTextControler [my set vobject] [self]
}
IDE::ObjectBrowser instproc printString {} {
    [self]::methodedit setTextControler [[my set vobject] printString] [self]
}
IDE::ObjectBrowser instproc save {} {
}
IDE::ObjectBrowser instproc setVarValue {value controller} {
    [self]::methodedit setTextControler $value $controller
}
IDE::ObjectBrowser instproc setViewList list {
    [self]::objectsview setList $list
}
IDE::ObjectBrowser instproc setViewObject object {
    my instvar vobject
    set vobject $object
    [self]::methodedit set context $object
    my setTitleAddition "$object ([$object info class])"
    [self]::varsview selectFor $object
    [self]::subobjectsview selectFor $object
    [self]::methodview selectFor $object
}
IDE::ObjectBrowser instproc specificInit {} {
    my instvar win type

    if {[IDE::System isTkNeverThan84]} {
        panedwindow $win.panedwindow -orient vertical
        panedwindow $win.upperarea -orient horizontal

        IDE::TclModeEdit [self]::methodedit $win.methodedit -height 16 -width 65
        if {$type!="single"} {
            IDE::ObjectsView [self]::objectsview $win.upperarea.objectsview
            set col 1
        } else {
            set col 0
        }
        IDE::VarsView [self]::varsview $win.upperarea.varsview
        IDE::SubObjectsView [self]::subobjectsview $win.upperarea.subobjectsview
        IDE::ObjectMethodView [self]::methodview $win.upperarea.methodview

        if { $col } {
            $win.upperarea add $win.upperarea.objectsview -width 200
        }
        $win.upperarea add $win.upperarea.varsview $win.upperarea.subobjectsview $win.upperarea.methodview -width 200

        $win.panedwindow add $win.upperarea -sticky news -height  120
        $win.panedwindow add $win.methodedit -sticky news -height 300

        pack $win.panedwindow -expand yes -fill both

    } else {
        IDE::TclModeEdit [self]::methodedit $win.methodedit -height 16 -width 65
        if {$type!="single"} {
            IDE::ObjectsView [self]::objectsview $win.objectsview
            set col 1
        } else {
            set col 0
        }

        IDE::VarsView [self]::varsview $win.varsview
        IDE::SubObjectsView [self]::subobjectsview $win.subobjectsview
        IDE::ObjectMethodView [self]::methodview $win.methodview

        grid $win.varsview -row 0 -column $col -sticky news
        grid $win.subobjectsview -row 0 -column [expr {$col+1}] -sticky news
        grid $win.methodview -row 0 -column [expr {$col+2}] -sticky news
        grid $win.methodedit -row 1 -column $col  -columnspan 3 -sticky news

        if {$type!="single"} {
            grid $win.objectsview -row 0 -column 0 -rowspan 2 -sticky news
        }

        grid columnconfigure $win $col -weight 1
        grid columnconfigure $win [expr {$col+1}] -weight 1
        grid columnconfigure $win [expr {$col+2}] -weight 1
        grid rowconfigure $win 1 -weight 1
    }
    if {$::xotcl::version>=1.3} {
        [self]::methodedit mixin add IDE::ContextEval
    } else {
        [self]::methodedit mixinappend IDE::ContextEval
    }
    [self]::methodedit set context Object

    my initStatusBar 2 [expr {3+$col}]
}
IDE::ObjectBrowser instproc trackObject {} {
    [my set vobject] trackOn
}
IDE::ObjectBrowser proc browseAllInstances class {
    if {![Object isobject $class] || ![$class istype Class]} {
        return
    }
    set objectList [lsort [$class info instances]]
    if {$objectList==""} {
        IDE::Dialog message "$class has no instances"
    } elseif {[llength $objectList]==1} {
        my newBrowser $objectList
    } else {
        my browseObjectsList $objectList
    }
}
IDE::ObjectBrowser proc browseAllObjectInstances {} {
    set instances {}
    foreach instance [Object info instances] {
        if {![Object isobject [$instance info parent]] || [Object isclass [$instance info parent]]} {
            lappend instances $instance
        }
    }
    my browseObjectsList [lsort $instances]
}
IDE::ObjectBrowser proc browseAllObjects {} {
    set instances {}
    set ignoreClasses(::Class) 1
    set ignoreClasses(::Object) 1
    foreach class [lsort [::Class info instances]] {
        if {[info exists ignoreClasses($class)]} continue
        foreach instance [$class info instances] {
            if {![Object isobject [$instance info parent]] || [Object isclass [$instance info parent]]} {
                lappend instances $instance
            }
        }
    }
    my browseObjectsList [lsort $instances]
}
IDE::ObjectBrowser proc browseObjectsList list {
    set newinst [my create [Object autoname browser] [Object autoname .browser] -type list]
    $newinst setViewList $list
    return $newinst
}
IDE::ObjectBrowser proc browseObjectsListCheck list {
    set olist {}
    foreach elem $list {
        if {[Object isobject $elem]} {
            lappend olist $elem
        }
    }
    if {$olist==""} {
        IDE::Dialog message {The list contains no Xotcl Objects}
    } else {
        my browseObjectsList $list
    }
}
IDE::ObjectBrowser proc newBrowser object {
    if {![Object isobject $object]} {
        return
    }
    set newinst [my new [Object autoname .objectbrowser]]
    $newinst setViewObject $object
    return $newinst
}
Class IDE::ObjectMethodView -superclass ::IDE::MethodView
@ ::IDE::ObjectMethodView idemeta component IDEView
IDE::ObjectMethodView instproc changeVisibility {} {
    my instvar vobject
    my selectFor $vobject
}
IDE::ObjectMethodView instproc fillMenuStruct ms {
    my set visibility MinusRoot
    $ms enablementHandler [self]

    $ms addCommand2 Invoke [list [self] dispatchWithSelected invokeMethod] isValidSelection
    $ms addCommand2 {Search Senders} [list [self] dispatchWithSelected searchSenders] isValidSelection
    $ms addCommand2 {Search Implementors} [list [self] dispatchWithSelected searchImplementors] isValidSelection
    $ms addRadioButton {Visibility All} [self]::visibility [list [self] changeVisibility] All
    $ms addRadioButton {Visibility Class} [self]::visibility [list [self] changeVisibility] Class
    $ms addRadioButton {Visibility All%::xotcl::Object} [self]::visibility [list [self] changeVisibility] MinusRoot
    $ms addCheckButton {no mixin methods} [self]::hideMixinMethod [list [self] changeVisibility]
    $ms addCheckButton {only instcommands} [self]::hideProcsMethod [list [self] changeVisibility]
    $ms addCheckButton {only procs} [self]::hideNoCmds [list [self] changeVisibility]
    $ms addCommand2 Refresh [list [self] changeVisibility]
}
IDE::ObjectMethodView instproc getMethodsFor {class visibility} {
    switch $visibility {
        Instance {
            return [ide::lcollect a [IDE::IntroProxy getInstanceMethods $class _all_categories] {list $a $class}]
        }
        All {
            return [$class getAllFullInstMethods]
        }
        MinusRoot {
            return [$class getAllFullInstMethods ::xotcl::Object]
        }
    }
}
IDE::ObjectMethodView instproc invokeMethod actual {
    set obj [[my info parent] set vobject]
    set method [lindex $actual 0]
    set signature [$obj procsearch $method]
    if {$signature==""} {
        if {[llength $actual]==2} {
            set class [lindex $actual 1]
            set args [$class info instargs $method]
        } else {
            IDE::System invokeInstproc $obj $method
            return
        }
    } else {
        set class [lindex $signature 0]
        set type [lindex $signature 1]
        if {$type=="proc"} {
            set args [$class info args $method]
        } else {
            set par [ide::lcollect each [$class info parameter] {lindex $each 0}]
            # method is a parameter
            if {[ide::lcontain $par $method]} {
                IDE::System invokeProcWithArg $obj $method value 1
            } else {
                IDE::System invokeInstproc $obj $method
            }
        }
    }
}
IDE::ObjectMethodView instproc searchImplementors actual {
    IDE::MethodBrowser searchImplementorsAll [lindex $actual 0]
}
IDE::ObjectMethodView instproc searchMixinClass {object method} {
    foreach c [$object info mixin] {
        foreach sc [concat $c [$c info heritage]] {
            if {[$sc info instprocs $method]!=""} {return $sc}
        }
    }
}
IDE::ObjectMethodView instproc searchSenders actual {
    IDE::MethodBrowser searchSendersAll [lindex $actual 0]
}
IDE::ObjectMethodView instproc selectFor object {
    my instvar vclass visibility vobject hideMixinMethod hideProcsMethod hideNoCmds
    if {![my exists hideMixinMethod]} {
        my set hideMixinMethod 0
    }
    if {![my exists hideProcsMethod]} {
        my set hideProcsMethod 0
    }
    if {![my exists hideNoCmds]} {
        my set hideNoCmds 0
    }
    set vcategories _all_categories
    set vobject $object
    if {$object==""} {
        my setList {}
    } else {
        set options {}
        foreach {var option} {hideMixinMethod -nomixins hideProcsMethod -noprocs hideNoCmds -nocmds} {
            if {[set $var]} {
                append options " $option"
            }
        }
        set methods [lsort -unique [eval $object info methods $options]]
        set class [$object info class]
        set smethods {}
        foreach m $methods {
            set dobj [lindex [$object procsearch $m] 0]
            # !!! if parameter has default the method below do not work
            # also yet no filtering. Maybe the user what to set parameter in this way
            # if {[ide::lcontain [$class info parameter] $m]} continue
            if {[$object info children $m]!=""} continue
            if {$dobj==""} {
                lappend smethods [list $m [my searchMixinClass $vobject $m]]
            } else {
                if {$visibility=="Class"} {
                    if {$dobj==$class} {
                        lappend smethods $m
                    }
                } elseif {$visibility=="MinusRoot"} {
                    if {$dobj!="::xotcl::Object"} {
                        lappend smethods [list $m [string trimleft $dobj :]]
                    }
                } else {
                    lappend smethods [list $m [string trimleft $dobj :]]
                }
            }
        }
        my setList $smethods
        set vclass $class
    }
    my selectItem {}
}
IDE::ObjectMethodView instproc selectItem method {
    my instvar vclass vtype vobject
    if {$method=="" || ![Object isobject $vobject]} return
    set def [$vobject procsearch [lindex $method 0]]
    if {$def==""} {
        set type Instance
        set class [lindex $method 1]
        set method [lindex $method 0]]
} else {
    set class [lindex $def 0]
    set dtype [lindex $def 1]
    set method [lindex $def 2]
    if {$dtype=="instproc"} {
        if {[$class info instprocs $method]!=""} {
            set type Instance
        } else {
            set body "# no access to $def"
            [my info parent]::methodedit setTextControler $body [self]
            return
        }
    } else {
        set type Class
    }
}
[my info parent]::methodedit setBodyTextControler [string trimleft $class :] $type $method [self]
}
Class IDE::ObjectsView -superclass {::IDE::ListView ::IDE::GUICommands}  -parameter {{type list}}
@ ::IDE::ObjectsView idemeta component IDEView
IDE::ObjectsView instproc selectItem object {
    my instvar type
    if {$type=="list"} {
        if {[Object isobject $object]} {
            [my info parent] setViewObject $object
            if {[Object isobject [my info parent]::methodedit]} {
                [my info parent]::methodedit setTextControler [$object printString] [self]
            }
        } else {
            IDE::Dialog message "$object does not longer exist. It will be removed from the list"
            my removeItem $object
        }
    }
}
Class IDE::PreferencesView -superclass {::IDE::Browser ::IDE::GUICommands}  -parameter {{atHead 1}}
@ ::IDE::PreferencesView idemeta component IDEView
IDE::PreferencesView instproc applyPreferences {} {
    my instvar changedColor win

    set aconf [font actual textfont_pref]
    if {[IDEPreferences getParameter textfont] ne $aconf} {
        IDEPreferences setParameter textfont $aconf
        eval font configure textfont $aconf
    }
    set aconf [font actual listboxfont_pref]
    if {[IDEPreferences getParameter listboxfont] ne $aconf} {
        IDEPreferences setParameter listboxfont $aconf
        eval font configure listboxfont $aconf
    }
    if {[info exists changedColor(text)]} {
        set color [$win.cframe.text_example cget -background]
        IDEPreferences setParameter textcolor $color
        IDE::Text setColor $color
        unset changedColor(text)
    }
    if {[info exists changedColor(listbox)]} {
        set color [$win.cframe.listbox_example cget -background]
        IDEPreferences setParameter listboxcolor $color
        IDE::ListView setColor $color
        unset changedColor(listbox)
    }
}
IDE::PreferencesView instproc cancelPreferences {} {
    my destroy
}
IDE::PreferencesView instproc changeColor color {
    my instvar win changedColor
    set examplewin $win.cframe.${color}_example
    set c [$examplewin cget -background]
    set ncolor [IDE::Dialog getColor $c]
    if {$ncolor ne ""} {
        set changedColor($color) 1
        $examplewin configure -background $ncolor
    }
}
IDE::PreferencesView instproc changeFont font {
    set fontname ${font}_pref
    set erg [IDE::FontChooser getFont [font actual $fontname]]
    if {$erg ne ""} {
        eval font configure $fontname $erg
    }
}
IDE::PreferencesView instproc createSystemMenu {} {
    my instvar win
    if {[winfo toplevel $win]=="."} {
        set twin {}
    } else {
        set twin $win
    }
    [winfo toplevel $win] configure -menu $twin.mb
}
IDE::PreferencesView instproc exportPreferences {} {
    set filename [IDE::Dialog getSaveFile xotclide]
    if {$filename ne ""} {
        IDEPreferences savePreferencesAsFile $filename
    }
}
IDE::PreferencesView instproc fillMenuStruct aMenuStruct {
    $aMenuStruct enablementHandler [self]

    $aMenuStruct addCommand {Import Preferences} [list [self] importPreferences]
    $aMenuStruct addCommand {Export Preferences} [list [self] exportPreferences]
}
IDE::PreferencesView instproc getMenuStruct {} {
    return [IDE::MenuStruct [self]::ms Preferences 0]
}
IDE::PreferencesView instproc getTitle {} {
    return Preferences
}
IDE::PreferencesView instproc importPreferences {} {
    set filename [IDE::Dialog getOpenFile]
    if {$filename ne ""} {
        IDEPreferences loadPreferencesFromFile $filename
        my refreshView
    }
}
IDE::PreferencesView instproc initFonts {} {
    if {[lsearch [font names] textfont_pref]<0} {
        font create textfont_pref
        font create listboxfont_pref
    }
}
IDE::PreferencesView instproc refreshView {} {
    my instvar win oldcolor changedColor
    eval font configure textfont_pref [IDEPreferences getParameter textfont]
    eval font configure listboxfont_pref [IDEPreferences getParameter listboxfont]
    set c [IDEPreferences getParameter textcolor]
    if {[info exists oldcolor(text)] && $oldcolor(text)!=$c} {
        set changedColor(text) 1
    }
    if {$c ne ""} {
        $win.cframe.text_example configure -background $c
    } else {
        $win.cframe.text_example configure -background [IDE::PreferencesView getDefaultColor text]
    }
    set oldcolor(text) $c
    if {[info exists oldcolor(listbox)] && $oldcolor(listbox)!=$c} {
        set changedColor(listbox) 1
    }
    set c [IDEPreferences getParameter listboxcolor]
    if {$c ne ""} {
        $win.cframe.listbox_example configure -background $c
    } else {
        $win.cframe.listbox_example configure -background [IDE::PreferencesView getDefaultColor text]
    }
    set oldcolor(listbox) $c
}
IDE::PreferencesView instproc savePreferences {} {
    IDEPreferences savePreferences
}
IDE::PreferencesView instproc setDefaults {} {
    IDEPreferences setDefaultPreferences
    my refreshView
}
IDE::PreferencesView instproc specificInit {} {
    my instvar win
    set fwin [frame $win.buttons]
    button $fwin.defaults -text "Set Defaults" -command [list [self] setDefaults]
    button $fwin.apply -text "Apply" -command [list [self] applyPreferences]
    button $fwin.save -text "Save" -command [list [self] savePreferences]
    button $fwin.cancel -text "Quit" -command [list [self] cancelPreferences]
    pack $fwin.defaults $fwin.apply $fwin.save $fwin.cancel -side left -anchor e


    frame $win.cframe

    label $win.cframe.eflab -text "Editor Font"
    label $win.cframe.lflab -text "Listview Font"
    my initFonts
    label $win.cframe.efexample  -border 2 -relief sunken -text "Example Text" -font textfont_pref
    label $win.cframe.lfexample  -border 2 -relief sunken -text "Example Text" -font listboxfont_pref
    button $win.cframe.efchange -text "Change" -command [list [self] changeFont textfont]
    button $win.cframe.lfchange -text "Change" -command [list [self] changeFont listboxfont]

    label $win.cframe.eclab -text "Editor Background"
    label $win.cframe.lclab -text "List Background"
    label $win.cframe.text_example  -border 2 -relief sunken
    label $win.cframe.listbox_example  -border 2 -relief sunken
    button $win.cframe.ecchange -text "Change" -command [list [self] changeColor text]
    button $win.cframe.lcchange -text "Change" -command [list [self] changeColor listbox]

    grid $win.cframe.eflab -column 0 -row 0
    grid $win.cframe.lflab -column 0 -row 1
    grid $win.cframe.efexample -column 1 -row 0 -sticky ew
    grid $win.cframe.lfexample -column 1 -row 1 -sticky ew
    grid $win.cframe.efchange -column 2 -row 0
    grid $win.cframe.lfchange -column 2 -row 1

    grid $win.cframe.eclab -column 0 -row 2
    grid $win.cframe.lclab -column 0 -row 3
    grid $win.cframe.text_example -column 1 -row 2 -sticky ew
    grid $win.cframe.listbox_example -column 1 -row 3 -sticky ew
    grid $win.cframe.ecchange -column 2 -row 2
    grid $win.cframe.lcchange -column 2 -row 3

    pack $win.cframe -expand yes -fill both -padx 10 -pady 10
    pack $win.buttons -side bottom -expand yes -anchor e -fill x
    my refreshView
    next
}
IDE::PreferencesView proc getDefaultColor typ {
    my instvar defaults
    if {![info exists defaults($typ)]} {
        set win [listbox .lll1]
        set defaults(listbox) [lindex [$win configure -background] 3]
        ::destroy $win
        set win [text .lll1]
        set defaults(text) [lindex [$win configure -background] 3]
        ::destroy $win
    }
    return $defaults($typ)
}
IDE::PreferencesView proc newBrowser {} {
    if {![Object isobject ::preferencesview]} {
        my create ::preferencesview .preferencesview
    }
}
Class IDE::ProcToMethodWizzard -superclass ::IDE::Browser  -parameter procedures
@ ::IDE::ProcToMethodWizzard idemeta component IDEView
IDE::ProcToMethodWizzard instproc actionConvert {} {
    my instvar targetClass procedures
    if {$targetClass==""} {
        IDE::Dialog error "Choose the target class first"
        return
    }
    foreach p $procedures {
        set body [IDE::IntroProxy getBodyTclMethod $p]
        if {$body==""} continue
        set method [namespace tail $p]
        if {[$targetClass info instprocs $method] ne ""} continue
        namespace eval :: $targetClass instproc $method [list [lindex $body 2]] \{\n[lindex $body 3]\}
    }
    my destroy
}
IDE::ProcToMethodWizzard instproc chooseClass {} {
    my instvar win targetClass
    set targetClass [IDE::ClassSelector getClass]
    $win.tframe.target configure -text $targetClass
}
IDE::ProcToMethodWizzard instproc createSystemMenu {} {
    # no menu
}
IDE::ProcToMethodWizzard instproc getTitle {} {
    return "Proc-To-Method Converter"
}
IDE::ProcToMethodWizzard instproc specificInit {} {
    my instvar win procedures

    frame $win.tframe
    frame $win.buttons -relief raised -border 3

    label $win.tframe.target -border 2 -width 40 -relief sunken -anchor w
    button $win.tframe.change -text "Choose Class" -command [list [self] chooseClass]
    pack $win.tframe.target $win.tframe.change -side left

    ::message $win.msg  -width 350 -text "Please use syntax checker to find all incompatible calls and variable references after converting. This tool do not work full automatic the converted methods must be manuelly adapted. (delete the the Tcl procedures before syntax check)" -padx 10 -pady 10

    button $win.buttons.ok -text "Convert Procedures" -command [list [self] actionConvert]
    button $win.buttons.cancel -text "Cancel" -command "destroy $win; [self] destroy" -underline 0

    pack $win.buttons.ok $win.buttons.cancel -side left

    pack $win.tframe -fill x -expand yes
    pack $win.msg
    pack $win.buttons -anchor w -ipady 10 -ipadx 6 -fill x

    set cancelscript "
               $win.buttons.cancel configure -state active -relief sunken
               update idletasks
               after 100
               [self] destroy"

    bind $win <Escape> $cancelscript
    bind $win <Alt-c> $cancelscript

    next
}
IDE::ProcToMethodWizzard proc convertProcedures procs {
    my new [Object autoname .procconverter] [list -procedures $procs]
}
Class IDE::ProtBrowser -superclass ::IDE::Browser
@ ::IDE::ProtBrowser idemeta component IDEView
IDE::ProtBrowser instproc append text {
    [self]::prottext append $text
}
IDE::ProtBrowser instproc specificInit {} {
    my instvar win
    IDE::ProtocolText [self]::prottext $win.resulttext

    grid $win.resulttext -row 0 -column 0 -sticky news

    grid columnconfigure $win 0 -weight 1
    grid rowconfigure $win 0 -weight 1
    next
}
IDE::ProtBrowser proc newBrowser {} {
    return [my new [Object autoname .protbrowser]]
}
Class IDE::ResultBrowser -superclass ::IDE::Browser  -parameter result
@ ::IDE::ResultBrowser idemeta component IDEView
IDE::ResultBrowser instproc getTitle {} {
    return {Result Browser}
}
IDE::ResultBrowser instproc setResult text {
    [self]::resulttext setText $text
}
IDE::ResultBrowser instproc specificInit {} {
    my instvar win result
    IDE::Editor [self]::resulttext $win.resulttext

    grid $win.resulttext -row 0 -column 0 -sticky news

    grid columnconfigure $win 0 -weight 1
    grid rowconfigure $win 0 -weight 1

    my setResult [my result]
    next
}
IDE::ResultBrowser proc newBrowser result {
    return [my new [Object autoname .result] [list -result $result]]
}
Class IDE::SpawnMethodEdit -superclass ::IDE::Browser
@ ::IDE::SpawnMethodEdit idemeta component IDEView
IDE::SpawnMethodEdit instproc createSystemMenu {} {
    next
    my instvar win
    if {[winfo toplevel $win]=="."} {
        set twin {}
    } else {
        set twin $win
    }
    $twin.mb add command -label "Invoke" -command [list [self] invoke]
}
IDE::SpawnMethodEdit instproc getTitle {} {
    return {Spawned Method Edit}
}
IDE::SpawnMethodEdit instproc invoke {} {
    set text [[self]::methodedit getText]
    if { [lindex $text 0] == "proc" } {
        IDE::System invokeTclProc [lindex $text 1]
    } else {
        set type [lindex $text 0]
        if { [Object isclass $type] } {
            switch [lindex $text 1] {
                "instproc" {
                    error "Can not direct call instance proc."
                }
                "proc" {
                    IDE::System invokeProc $type [lindex $text 2]
                }
                default {
                    error "Unknown method type to call."
                }
            }
        } else {
            error "Can call only proc or class proc."
        }
    }
}
IDE::SpawnMethodEdit instproc specificInit {} {
    my instvar win
    IDE::TclModeEdit [self]::methodedit $win.methodedit
    pack $win.methodedit -fill both -expand yes
}
Class IDE::SubObjectsView -superclass {::IDE::HListView ::IDE::GUICommands}  -parameter {{label Subobjects}}
@ ::IDE::SubObjectsView idemeta component IDEView
IDE::SubObjectsView instproc fillMenuStruct ms {
    $ms enablementHandler [self]

    $ms addCommand2 {Inspect in new window} [list [self] inspectObject] isValidSelection
    $ms addCommand2 {Inspect in this window} [list [self] inspectObjectInThis] isValidSelection
    $ms addCommand2 {Inspect Parent} [list [my info parent] inspectParent] isValidParent
    $ms addCommand2 {Refresh} [list [self] refresh]
    next
}
IDE::SubObjectsView instproc getMenuStruct {} {
    return [IDE::MenuStruct [self]::ms Subobjects 4]
}
IDE::SubObjectsView instproc inspectObject {} {
    set actual [my selectionAsObject]
    if {$actual==""} return
    $actual inspect
}
IDE::SubObjectsView instproc inspectObjectInThis {} {
    set actual [my selectionAsObject]
    if {$actual==""} return
    [my info parent] setViewObject $actual
}
IDE::SubObjectsView instproc isValidParent {} {
    my instvar vobject
    expr {[set parent [$vobject info parent]]!="::" && [Object isobject $parent]}
}
IDE::SubObjectsView instproc refresh {} {
    my instvar vobject
    my setHList [lrange [$vobject getSubobjectsHierarchy] 1 end]
    my selectItem {}
}
IDE::SubObjectsView instproc selectFor object {
    my instvar vobject
    set vobject $object
    my setHList [lrange [$vobject getSubobjectsHierarchy] 1 end]
    my selectItem {}
}
IDE::SubObjectsView instproc selectItem object {
    set object [my selectionAsObject]
    if {$object==""} return
    if {[Object isobject [my info parent]::methodedit]} {
        [my info parent]::methodedit setTextControler [$object printString] [self]
    }
}
IDE::SubObjectsView instproc selectionAsObject {} {
    my instvar objlist
    set index [my selectedIndex]
    if {$index==""} return
    return [lindex $objlist $index]
}
IDE::SubObjectsView instproc setList list {
    my instvar objlist
    set translist {}
    set objlist {}
    foreach elem $list {
        lappend objlist [string trimleft $elem]
        set pre {}
        regexp { +} $elem pre
        lappend translist "$pre[namespace tail [string trimleft $elem]]"
    }
    next $translist
}
Class IDE::SyntaxCheckMethodList -superclass {::IDE::NListView ::IDE::GUICommands}
@ ::IDE::SyntaxCheckMethodList idemeta component IDEView
IDE::SyntaxCheckMethodList instproc browseChildren actual {
    set item [split $actual >]
    set vclass [lindex [lindex $item 0] 0]
    if {[Object isclass $vclass]} {
        IDE::HeritageBrowser newBrowserChild $vclass
    } else {
        my upsMessage "$vclass is not a class"
    }
}
IDE::SyntaxCheckMethodList instproc browseHeritage actual {
    set item [split $actual >]
    set vclass [lindex [lindex $item 0] 0]
    if {[Object isclass $vclass]} {
        IDE::HeritageBrowser newBrowser $vclass
    } else {
        my upsMessage "$vclass is not a class"
    }
}
IDE::SyntaxCheckMethodList instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms addCommand2 {Remove from List} [list [self] dispatchWithSelected removeMethod] isValidSelection
    $ms addCommand2 {Heritage Browser} [list [self] dispatchWithSelected browseHeritage] isValidSelection
    $ms addCommand2 {Children Browser} [list [self] dispatchWithSelected browseChildren] isValidSelection
    $ms addCommand2 {Search Senders} [list [self] dispatchWithSelected searchSenders] isValidSelection
    my menuInsertions $ms
    next
}
IDE::SyntaxCheckMethodList instproc getMenuStruct {} {
    return [IDE::MenuStruct create [self]::ms Methods 0]
}
IDE::SyntaxCheckMethodList instproc removeMethod actual {
    [my info parent] removeMethod
}
IDE::SyntaxCheckMethodList instproc searchSenders actual {
    set method [lindex [split $actual >] 1]
    IDE::MethodBrowser searchSendersAll $method
}
Class IDE::SyntaxChecker -superclass {::IDE::Browser ::IDE::GUICommands}  -parameter {{atHead 1}}
@ ::IDE::SyntaxChecker idemeta categories {initialize viewing}
@ ::IDE::SyntaxChecker idemeta categoriesMethods {{getTitle getMenuStruct fillMenuStruct specificInit} {selectError selectMethod}}
@ ::IDE::SyntaxChecker idemeta component IDEView
IDE::SyntaxChecker instproc checkComponents {} {
    my instvar errorsArr
    set components [[self]::components selectedItem]
    if {$components==""} {
        IDE::Dialog message "No componets selected"
        return
    }
    catch {unset errorsArr}
    [self]::messages setList {}
    set c 0
    set report [time {
        foreach component $components {
            set cobj [IDE::Component getCompObjectForNameIfExist $component]
            foreach cls [$cobj getClasses] {
                foreach method [$cls info instprocs] {
                    set chk [PrsContext new]
                    $chk parseAndCheck [IDE::IntroProxy getBodyInstanceMethod $cls $method]
                    my setStateText "$cls [incr c]"
                    if {[$chk hasErrors]} {
                        set errorsArr($cls>$method) [$chk errors]
                    }
                    $chk destroy
                    update
                }
                foreach method [$cls info procs] {
                    set chk [PrsContext new]
                    $chk parseAndCheck [IDE::IntroProxy getBodyClassMethod $cls $method]
                    my setStateText "$cls [incr c]"
                    if {[$chk hasErrors]} {
                        set errorsArr($cls\ class>$method) [$chk errors]
                    }
                    $chk destroy
                    update
                }
            }
            foreach obj [$cobj getObjects] {
                foreach method [$obj info procs] {
                    if {$method=="-"} continue
                    set chk [PrsContext new]
                    $chk parseAndCheck [IDE::IntroProxy getBodyClassMethod $obj $method]
                    my setStateText "$obj [incr c]"
                    if {[$chk hasErrors]} {
                        set errorsArr($obj\ class>$method) [$chk errors]
                    }
                    $chk destroy
                    update
                }
            }
            foreach gobj [$cobj getProcsGroupsObjects] {
                foreach method [$gobj getProcsNames] {
                    set chk [PrsContext new]
                    $chk parseAndCheck [IDE::IntroProxy getProcBody $method]
                    my setStateText "procs [incr c]"
                    if {[$chk hasErrors]} {
                        set errorsArr(proc\ $method) [$chk errors]
                    }
                    $chk destroy
                    update
                }
            }
        }
    }]
    my setStateText "$report $c methods"
    my setListViews
}
IDE::SyntaxChecker instproc excludeIDE {} {
    set idecore [concat [IDE::System getCoreComponentsAll] [IDE::System getExtraComponents]]
    foreach index [[self]::components selectedIndex] item [[self]::components selectedItem] {
        if {[ide::lcontain $idecore $item]} {
            [self]::components removeSelection $index $index
        }
    }
}
IDE::SyntaxChecker instproc fillMenuStruct aMenuStruct {
    $aMenuStruct addCommand {Protokoll to File} [list [self] protokollToFile]
}
IDE::SyntaxChecker instproc getBodyForItem item {
    if {[lindex $item 0]=="proc"} {
        return [IDE::IntroProxy getProcBody [lindex $item 1]]
    } else {
        set item [split $item >]
        set method [lindex $item 1]
        set vtype [lindex [lindex $item 0] 1]
        if {$vtype==""} { set vtype Instance} else { set vtype Class}
        set vclass [lindex [lindex $item 0] 0]
        return [IDE::IntroProxy getBody${vtype}Method $vclass $method]
    }
}
IDE::SyntaxChecker instproc getMenuStruct {} {
    return [IDE::MenuStruct [self]::ms {Syntax Check} 0]
}
IDE::SyntaxChecker instproc getTitle {} {
    return {Syntax Checker Browser}
}
IDE::SyntaxChecker instproc protokollToFile args {
    my instvar errorsArr
    if {![array exists errorsArr]} {
        IDE::Dialog message "No errors to protokoll. Run a checker first"
        return
    }
    set file [IDE::Dialog getSaveFile errors.txt]
    if {$file==""} return
    set pfile [open $file w]
    for {set sid [array startsearch errorsArr]} {[array anymore errorsArr $sid]} {} {
        set method [array nextelement errorsArr $sid]
        set errors $errorsArr($method)
        set char 0
        set index 0
        set end 0
        foreach line [split [my getBodyForItem $method] \n] {
            puts $pfile $line
            incr char [string length $line]
            incr char
            if {!$end && $char>[lindex [lindex $errors $index] 0]} {
                puts $pfile "-----> [lindex [lindex $errors $index] 2]"
                incr index
                if {$index>=[llength $errors]} {
                    set end 1
                }
            }
        }
    }
    array donesearch errorsArr $sid
    close $pfile
}
IDE::SyntaxChecker instproc readComponents {} {
    [self]::components setList [IDE::IntroProxy getComponents]
}
IDE::SyntaxChecker instproc removeMethod {} {
    my instvar errorsArr
    set item [[self]::methods selectedItem]
    if {$item==""} return
    if {[array exists errorsArr]} {
        unset errorsArr($item)
        my setListViews
    }
}
IDE::SyntaxChecker instproc selectAll {} {
    [self]::components addSelection 0 end
}
IDE::SyntaxChecker instproc selectError item {
    set index [[self]::messages selectedIndex]
    set error [lindex [my set errors] $index]
    [self]::body removeColorize
    [self]::body colorizeRange [lindex $error 0] [expr {[lindex $error 1]+1}]
    [self]::body viewPos [lindex $error 0]

}
IDE::SyntaxChecker instproc selectMethod item {
    my instvar errors errorsArr
    set errors $errorsArr($item)
    [self]::body setTextType [my getBodyForItem $item] xotcl
    [self]::messages setListUnsorted [ide::lcollect each $errors {lindex $each 2}]
    # !!! no save controller
}
IDE::SyntaxChecker instproc setListViews {} {
    my instvar errorsArr
    if {[array exists errorsArr]} {
        [self]::methods setList [array names errorsArr]
    } else {
        [self]::methods setList {}
    }
    [self]::messages setListUnsorted {}
}
IDE::SyntaxChecker instproc setStateText text {
    my setStatusBarText $text
    update idletasks
}
IDE::SyntaxChecker instproc specificInit {} {
    my instvar win

    set panned [IDE::System isTkNeverThan84]

    if {$panned} {
        panedwindow $win.panedwindow -orient vertical
        set topwin [panedwindow $win.upperarea -orient horizontal]
    } else {
        set topwin [frame $win.sel]
    }
    set mainframe [frame $win.mframe]
    set bframe [frame $mainframe.bframe]

    IDE::ListView create [self]::components $topwin.components -multiselect 1 -label "Components Alt-1"
    IDE::SyntaxCheckMethodList create [self]::methods $topwin.methods -notify [self] -notifyProc selectMethod -width 45 -label "Methods Alt-2"
    IDE::NListView create [self]::messages $topwin.messages -notify [self] -notifyProc selectError -width 40 -label "Errors Alt-3 (Alt-n/p next/prev)"

    button $bframe.check -text "Check Selected" -underline 0 -command [list [self] checkComponents]
    button $bframe.all -text "Select All Components" -underline 7 -command [list [self] selectAll]
    button $bframe.allTcl -text "Exclude IDE Components" -underline 1 -command [list [self] excludeIDE]

    IDE::TclModeEdit [self]::body $mainframe.body -mixin IDE::CodeController

    pack $bframe.check $bframe.all $bframe.allTcl -side left -anchor nw
    pack $bframe -side top -anchor nw -fill x
    pack $mainframe.body -fill both -side bottom -expand 1

    if {$panned} {
        $topwin add $topwin.components $topwin.methods $topwin.messages -width 200
        $win.panedwindow add $topwin -sticky news -height  160
        $win.panedwindow add $mainframe -sticky news -height 260
        pack $win.panedwindow -expand yes -fill both
    } else {
        pack $topwin.components $topwin.methods $topwin.messages -side left -expand 1 -fill both
        pack $topwin -anchor w -expand 0 -fill x
        pack $mainframe -anchor w -expand 1 -fill both
    }

    bind $win <Alt-a> [list [self] selectAll]
    bind $win <Alt-c> [list [self] checkComponents]
    bind $win <Alt-x> [list [self] excludeIDE]
    bind $win <Alt-p> [list [self]::messages selectPrevItem]
    bind $win <Alt-n> [list [self]::messages selectNextItem]

    bind $win <Alt-KeyPress-1> [list focus [[self]::components getFocusWin]]
    bind $win <Alt-KeyPress-2> [list focus [[self]::methods getFocusWin]]
    bind $win <Alt-KeyPress-3> [list focus [[self]::messages getFocusWin]]

    my readComponents

    focus [[self]::components getFocusWin]

    next

    my initStatusBar -1
    my setStatusBarText "This tool check the syntax in selected components"
}
IDE::SyntaxChecker proc newBrowser {} {
    return [my new [Object autoname .syntax]]
}
Class IDE::SyntaxErrorView -superclass ::IDE::Browser  -parameter {errors editor controler}
@ ::IDE::SyntaxErrorView idemeta component IDEView
IDE::SyntaxErrorView instproc createSystemMenu {} {
    # no system menu
}
IDE::SyntaxErrorView instproc destroy {} {
    if {[Object isobject [my editor]]} {
        [my editor] dropAllColorized
    }
    next
}
IDE::SyntaxErrorView instproc forceSaving {} {
    [my editor] saveForce
    my destroy
}
IDE::SyntaxErrorView instproc getTitle {} {
    return {Syntax Errors}
}
IDE::SyntaxErrorView instproc selectError item {

    set index [[self]::errorlist selectedIndex]
    set error [lindex [my errors] $index]
    [my editor] colorizeRange [lindex $error 0] [expr {[lindex $error 1]+1}]
    [my editor] viewPos [lindex $error 0]
}
IDE::SyntaxErrorView instproc specificInit {} {
    my instvar win

    message $win.message -text {Found possible syntax error(s)! If you want to prevent checking in this method place magic text "no syntax check" in it.} -width 350

    IDE::NListView [self]::errorlist $win.errorlist -notify [self] -notifyProc selectError -height 15 -width 50

    frame $win.buttons
    button $win.buttons.cancel -text "Cancel Saving (Esc)" -command [list [self] destroy]
    button $win.buttons.force -text "Force Saving (Enter)" -default active -command [list [self] forceSaving]
    set cancelscript "
               $win.buttons.cancel configure -state active -relief sunken
               update idletasks
               after 100
               [self] destroy"
    set okscript "
               $win.buttons.force configure -state active -relief sunken
               update idletasks
               after 100
               [self] forceSaving
               break"
    bind $win <KeyRelease-Return> $okscript
    bind $win <Escape> $cancelscript
    bind $win <Alt-n> [list [self]::errorlist selectNextItem]
    bind $win <Alt-p> [list [self]::errorlist selectPrevItem]

    pack $win.message  -anchor w -expand yes -fill x
    pack $win.errorlist -fill both -expand yes
    pack $win.buttons -anchor w
    pack $win.buttons.cancel $win.buttons.force -side left
    [self]::errorlist setListUnsorted [ide::lcollect each [my errors] {lindex $each 2}]
    focus $win
    next
}
Class IDE::TclGroupDefinition -superclass ::IDE::Browser  -parameter {classView {mode define}}
@ ::IDE::TclGroupDefinition idemeta component IDEView
IDE::TclGroupDefinition instproc actionCreate {} {
    my instvar isnamespace groupName classView
    if {[my checkClassView]} {
        if {[my mode]=="redefine"} {
            # !!!
        } else {
            if {![my getValuesFromGUI]} return
            $classView createTclProcsGroup $groupName $isnamespace
        }
    }
    my destroy
}
IDE::TclGroupDefinition instproc checkClassView {} {
    my instvar classView
    return [Object isobject $classView]
}
IDE::TclGroupDefinition instproc createSystemMenu {} {
    # no system menu
}
IDE::TclGroupDefinition instproc destroy {} {
    my instvar win
    ::destroy $win
    next
}
IDE::TclGroupDefinition instproc getTitle {} {
    return {Tcl-Proc-Group Definition}
}
IDE::TclGroupDefinition instproc getValuesFromGUI {} {
    my instvar win groupName
    set groupName [$win.fname.name get]
    if {$groupName==""} {
        IDE::Dialog error "You must specify new name for the tcl group"
        return 0
    }
    return 1
}
IDE::TclGroupDefinition instproc specificInit {} {
    my instvar win

    frame $win.buttons -relief raised -border 3
    frame $win.fname

    message $win.message -text {Give new name for tcl procs group} -width 250
    label $win.fname.lname -text Name
    entry $win.fname.name

    my requireNamespace
    checkbutton $win.isnamespace -text "use name as Tcl namespace" -variable [self]::isnamespace

    button $win.buttons.ok -text Create -command [list [self] actionCreate]
    button $win.buttons.cancel -text Cancel -command "destroy $win; [self] destroy"
    pack $win.buttons.ok $win.buttons.cancel -side left
    pack $win.fname.lname $win.fname.name -side left
    pack $win.message
    pack $win.fname -anchor w
    pack $win.isnamespace -anchor w
    pack $win.buttons -anchor w -ipady 10 -ipadx 6 -fill x

    next
}
IDE::TclGroupDefinition proc newGroup view {
    return [my new [Object autoname .tgdbrowser] -classView $view]
}
IDE::TclGroupDefinition proc unknown args {
    error "unknown method on [self] $args"
}
Class IDE::Transcript -superclass ::IDE::Browser
@ ::IDE::Transcript idemeta component IDEView
IDE::Transcript instproc destroy {} {
    next
}
IDE::Transcript instproc getTitle {} {
    if {[self]=="::transcript"} {
        return Transcript
    } else {
        return Workspace
    }
}
IDE::Transcript instproc specificInit args {
    my instvar win

    IDE::EditorTranscript [self]::editor $win.editor
    global tcl_patchLevel
    if {$win==".f"} {
        wm protocol [winfo toplevel $win] WM_DELETE_WINDOW [list IDE::System exitIDEGUI]
        $win.editor.text insert 0.1 "Artur Trzewik 2001 all rights reserved\nXOTclIDE Version [IDE::System getVersion] 02.2005\nInteractive Developing System for Tcl $tcl_patchLevel / XOTcl [set xotcl::version][set xotcl::patchlevel]\nGNU Public License Software\nXOTclIDE comes with ABSOLUTELY NO WARRANTY See the GNU General Public License for more details.\n\nREADY"
    }
    pack $win.editor -side bottom -expand yes -fill both

    next
}
IDE::Transcript instproc warning string {
    [self]::editor appendToCursor "\n$string"
}
IDE::Transcript proc buildMain {} {
    if {[Object isobject ::transcript]} {
        return
    }
    frame .f
    pack .f -fill both -expand yes
    my create ::transcript .f
}
IDE::Transcript proc newBrowser {} {
    return [my new [Object autoname .workspace]]
}
IDE::Transcript proc warning string {
    if {[Object isobject ::transcript]} {
        ::transcript warning $string
    }
}
@ Object IDE::PlugInsManager {
    description {# PlugIns List Format

        Name Label Component Startscript DepComponent}
}
Object IDE::PlugInsManager
@ ::IDE::PlugInsManager idemeta component IDEView
IDE::PlugInsManager proc getMenuStruct ms {
    my instvar plugInsArr plugInsList
    if {![info exists plugInsArr]} return
    IDE::MenuStruct ${ms}::extras {Plug Ins}
    $ms addCascadeMenu ${ms}::extras
    foreach key $plugInsList {
        set value $plugInsArr($key)
        set label [lindex $value 1]
        ${ms}::extras addCommand $label [list [self] loadExtras $key]
    }
}
IDE::PlugInsManager proc loadExtras extra {
    my instvar plugInsArr plugInsList
    if {![ide::lcontain $plugInsList $extra]} {
        error "$extra is not registered plug in"
    }
    foreach {Name Label Component Startscript DepPlugInsList} $plugInsArr($extra) {}
    foreach dep $DepPlugInsList {my loadExtras $dep}
    IDE::SystemConfigMap loadComponentFromAny $Component
    namespace eval :: $Startscript
}
IDE::PlugInsManager proc readPlugInsList {{file {}}} {
    my instvar plugInsArr plugInsList
    if {$file==""} {
        set file [file join [IDE::System getSystemDir] pluginslist.txt]
    }
    if {![file exists $file]} return
    set fh [open $file r]
    while {[gets $fh line]>=0} {
        if {[string match #* $line] || $line==""} continue
        lappend plugInsList [lindex $line 0]
        set plugInsArr([lindex $line 0]) $line
    }
    close $fh
}
@ Object IDE::System {
description {This object held the system generic methods as
1. quering envirorments parameters (directory, user)
2. specify systems menu
3. quering systems constants
4. evaluate user scripts
}
}
Object IDE::System
@ ::IDE::System idemeta categoriesMethodsProcs {{signalComponentsChanged versionAllCoreComponents showFreshMethods inspectString loadExtras exitIDEGUI} {getUserId getSystemDir getCoreComponentsAll getXotclPackages isTkNeverThan84 getExtraComponents getCoreComponents getMenuStruct getVersion} {handleResult tryBrowseAsObjectList createInstance invokeProc invokeTclProc invokeInstproc invokeProcWithArg} {evalString evalInspectString substituteString browseString invokeTclProcWithArg} {showBusyWhile isDatabase} {initDatabase initDatabaseNoConnect initializeAfterLoad}}
@ ::IDE::System idemeta categoriesProcs {actions system-constans invoke-action eval-action service initializing}
@ ::IDE::System idemeta component IDEView
IDE::System proc browseString string {
    if {[Object isclass $string]} {
        IDE::HeritageBrowser newBrowser $string
    } elseif {[Object isobject $string]} {
        IDE::ObjectBrowser newBrowser $string
    } else {
        if {[my tryBrowseAsObjectList $string]} return
        if {![IDE::MethodBrowser searchImplementorsAll $string 1]} {
            IDE::Dialog message "$string is not a Class, Object (Objects list) or method name"
        }
    }
}
IDE::System proc createInstance class {
    if {![Object isclass $class]} { error "$class is not Xotcl Class"}
    set arguments {}
    if {[$class info instprocs init]!=""} {
        foreach arg [$class info instargs init] {
            if {[$class info instdefault init $arg val]} {
                lappend arguments [list $arg $val]
            } else {
                lappend arguments $arg
            }
        }
    }
    set parameters {}
    foreach par [$class info parameter] {
        lappend parameters [lindex $par 0]
    }
    set ret [IDE::IDialogEntry getValueWithCancel "Create instance of $class\n$arguments\n$parameters"]
    if {$ret=="_cancel"} return
    if {$ret!=""} {
        return [namespace eval :: $class create [Object autoname sample] $ret]
    } else {
        return [namespace eval :: [list $class create [Object autoname sample]]]
    }
}
IDE::System proc evalInspectString string {
    set res [my evalString $string]
    my inspectString $res
}
IDE::System proc evalString string {
    namespace eval :: $string
}
IDE::System proc exitIDEGUI {} {
    if {[IDE::Dialog yesNo {Do you want to exit XOTclIDE?}]} {
        exit
    }
}
IDE::System proc getCoreComponents {} {
    list IDEStart IDECore IDEBaseGUI IDEPersistenceGUI IDEView xdobry::mysql xdobry::sql xdobry::pgsql xdobry::odbc xdobry::sqlite xdobry::access xdobry::mssql xdobry::oratcl IDEPersistence IDEEditor IDEDebug IDEPersistenceAdd IDEErrorReporter IDETclParser
}
IDE::System proc getCoreComponentsAll {} {
    return [concat [my getCoreComponents] core default]
}
IDE::System proc getExtraComponents {} {
    list IDETestFramework IDETests IDEVCInstaller IDEDocumentation IDEConfiguration IDEPersistenceTests xdobry::sqlDebug IDEExtendedDebugger IDEWikiReaper IDEKitDeployer IDEScriptEditor IDERepositoryImporter IDETkWinInspector IDESQLBrowser IDEFileBrowser IDERegexpBrowser IDEInternationalizationHelper
}
IDE::System proc getMenuStruct {} {
    set mobj [self]::ms
    if {[Object isobject $mobj]} {
        return $mobj
    }
    set ms [IDE::MenuStruct $mobj System 0]
    $ms addMenuItem [IDE::MenuCommand new -childof $mobj -accelerator {F5} -name {Component Browser} -command [list IDE::CompBrowser newBrowser]]
    $ms addCommand {Global Vars Inspector} [list IDE::GlobalVarsInspector startBrowser]
    $ms addCommand {Heritage Browser} [list IDE::HeritageBrowser newBrowser]
    $ms addCommand {Syntax Checker} [list IDE::SyntaxChecker newBrowser]
    $ms addCommand {Workspace} [list IDE::Transcript newBrowser]
    $ms addCommand {Configuration Map Browser}  [list IDE::ConfigurationBrowser showBrowser]
    $ms addCommand {Method Tracker Browser} [list IDE::TrackerBrowser openBrowser]
    $ms addCommand {Variable Tracker Browser} [list IDE::VarsTracker newBrowser]
    $ms addCommand {Coverage Analyse Browser} [list IDE::CallingCoverBrowser newBrowser]
    $ms addCommand {Preferences} [list IDE::PreferencesView newBrowser]
    $ms addCheckButton {Enable Breakpoints} IDE::Debugger::shouldHalt {}
    $ms addCheckButton {Ignore IDE Comp.} [self]::ignoreIDE {}
    global tcl_platform
    if {[my isWindowsPlatform]} {
        $ms addCommand {Tcl Console} [list console show]
    }
    IDE::MenuStruct ${ms}::help {Help (external links)}
    $ms addCascadeMenu ${ms}::help
    ${ms}::help addCommand {Tcl/Tk Homepage} [list IDE::System openHTMLBrowser {http://www.tcl.tk}]
    ${ms}::help addCommand {XOTcl Manual} [list IDE::System openHTMLBrowser {http://www.xotcl.org/xotclide/}]
    ${ms}::help addCommand {XOTclIDE Manual} [list IDE::System openHTMLBrowser {http://media.wu-wien.ac.at/doc/index.html}]
    ${ms}::help addCommand {Tcl/Tk Wiki} [list IDE::System openHTMLBrowser {http://mini.net/tcl}]
    ${ms}::help addCommand {XOTclIDE on Wiki} [list IDE::System openHTMLBrowser {http://mini.net/tcl/2131}]

    $ms addSeparator

    $ms addCommand {Inspect All Objects} [list IDE::ObjectBrowser browseAllObjects]
    $ms addCommand {Inspect All Object Instances} [list IDE::ObjectBrowser browseAllObjectInstances]
    $ms addCommand {Search Implementors} [list IDE::MethodBrowser searchImplementorsDialog]
    $ms addCommand {Search Breakpoints} [list IDE::MethodBrowser searchBreakPoints]
    IDE::MenuStruct ${ms}::edebug {Extended Debugger}
    $ms addCascadeMenu ${ms}::edebug

    if {[Object isobject IDE::ExtendedDebugger]} {
        IDE::ExtendedDebugger appendMenu ${ms}::edebug
    } else {
        ${ms}::edebug addCommand {Load Debugger} [list [self] loadExtras ExtendedDebugger]
    }
    IDE::PlugInsManager getMenuStruct $ms
    if {[my isDatabase]} {
        IDE::MenuStruct ${ms}::vcontrol {Version Control}
        $ms addCascadeMenu ${ms}::vcontrol
        ${ms}::vcontrol addCommand {Show Fresh Methods} [list [self] showFreshMethods]
        ${ms}::vcontrol addCommand {Sql Monitor} [list [self] loadExtras sqlDebuger]
        ${ms}::vcontrol addCommand {Configuration Browser} [list [self] loadExtras Configuration]
    }
    $ms addSeparator
    $ms addCommand "Quit XOTclIDE" [list IDE::System exitIDEGUI]
    return $ms
}
IDE::System proc getSystemDir {} {
    global xotclidedir
    return $xotclidedir
}
IDE::System proc getUserId {} {
    IDE::User getDefaultUserId
}
IDE::System proc getVersion {} {
    return 0.73
}
IDE::System proc getXotclPackages {} {
    # I dont know any method to request the available xotcl packages
    return [split {xotcl::awo::htmlPlace
xotcl::awo::secureHtmlPlace
xotcl::awo::userMgt
xotcl::awo::webAgent
xotcl::awo::webDocument
xotcl::comm::connection
xotcl::comm::dav
xotcl::comm::ftp
xotcl::comm::httpAccess
xotcl::comm::httpd
xotcl::comm::imap
xotcl::comm::ldap
xotcl::comm::mime
xotcl::comm::pcache
xotcl::htmllib
xotcl::metadataAnalyzer
xotcl::mixinStrategy
xotcl::mos::agent
xotcl::mos::agentManagement
xotcl::mos::httpPlace
xotcl::mos::invoker
xotcl::mos::placeAccessControl
xotcl::mos::secureHttpPlace
xotcl::mos::sendStrategy
xotcl::mos::webObject
xotcl::package
xotcl::pattern::adapter
xotcl::pattern::chainOfResponsibility
xotcl::pattern::composite
xotcl::pattern::link
xotcl::pattern::manager
xotcl::pattern::observer
xotcl::pattern::onCalleeProxy
xotcl::pattern::singleton
xotcl::pattern::sortedCompositeWithAfter
xotcl::rdf::parser
xotcl::rdf::recreatorVisitor
xotcl::rdf::triple
xotcl::rdf::tripleRecreator
xotcl::registry::registry
xotcl::script
xotcl::scriptCreation::recoveryPoint
xotcl::scriptCreation::scriptCreator
xotcl::scriptCreation::serializer
xotcl::staticMetadataAnalyzer
xotcl::store
xotcl::store::gdbm
xotcl::store::jufgdbm
xotcl::store::mem
xotcl::store::persistence
xotcl::store::sdbm
xotcl::store::tclgdbm
xotcl::store::textfile
xotcl::store::trace
xotcl::trace
xotcl::wafecompat
xotcl::xml::parser
xotcl::xml::printVisitor
xotcl::xml::recreatorVisitor
xotcl::xodoc}]
}
IDE::System proc handleResult result {
    IDE::ResultBrowser newBrowser $result
}
IDE::System proc ignoreIDEComponents switch {
    my set ignoreIDE $switch
}
IDE::System proc initDatabase {} {
    my instvar isDatabase
    IDEPreferences loadPreferences
    IDE::DBPersistence connect
    IDE::User initDefault
    set isDatabase 1
}
IDE::System proc initDatabaseNoConnect {} {
    my instvar isDatabase
    IDE::DBPersistence initSchema
    IDE::User initDefault
    set isDatabase 1
}
IDE::System proc initializeAfterLoad {} {
    my set ignoreIDE 0
    my requireNamespace
}
IDE::System proc inspectString res {
    if {$res==""} {
        IDE::Dialog message "No result"
    } elseif {[Object isobject $res]} {
        $res inspect
    } else {
        if {[my tryBrowseAsObjectList $res]} return
        my handleResult $res
    }
}
IDE::System proc invokeInstproc {object instproc} {
    if {![Object isobject $object] || ![Object isclass [$object info class]]} return
    set arguments [list]
    set defcount 0
    set p [$object procsearch $instproc]
    set class [lindex $p 0]
    foreach arg [$class info instargs $instproc] {
        if {[$class info instdefault $instproc $arg val]} {
            incr defcount
            lappend arguments [list $arg $val]
        } else {
            lappend arguments $arg
        }
    }
    if {$::xotcl::version>=1.3} {
        my invokeProcWithArg $object $instproc $arguments $defcount [$class info instnonposargs $instproc]
    } else {
        my invokeProcWithArg $object $instproc $arguments $defcount
    }
}
IDE::System proc invokeProc {object proc} {
    if {![Object isobject $object]} return
    set arguments {}
    set defarguments 0
    foreach arg [$object info args $proc] {
        if {[$object info default $proc $arg val]} {
            lappend arguments [list $arg $val]
            incr defarguments
        } else {
            lappend arguments $arg
        }
    }
    my invokeProcWithArg $object $proc $arguments $defarguments
}
IDE::System proc invokeProcWithArg {object proc arg {defargumentsCount 0} {noposarg {}}} {
    if {$arg==""} {
        set r [$object $proc]
    } else {
        while 1 {
            set ret [IDE::IDialogEntry getValueWithCancel "$object $proc\ngive the parameter list\n$arg"]
            if {$ret=="_cancel"} return
            # no check by nopos arguments TODO
            if {$noposarg!=""} break
            if {[lindex $arg end]=="args" && [llength $ret]>=[llength $arg]-1-$defargumentsCount} break
            if {[llength $ret]<=[llength $arg] && [llength $ret]>=[llength $arg]-$defargumentsCount} break
            IDE::Dialog message {Wrong length of param list}
        }
        set r [namespace eval :: $object $proc $ret]
    }
    if {$r==""} {
        IDE::Dialog message "empty result from $object $proc \n args :[string range $r 0 30]"
    } else {
        my inspectString $r
    }
}
IDE::System proc invokeTclProc proc {
    set arguments [list]
    set defargCount 0
    foreach arg [::info args $proc] {
        if {[::info default $proc $arg val]} {
            lappend arguments [list $arg $val]
            incr defargCount
        } else {
            lappend arguments $arg
        }
    }
    my invokeTclProcWithArg $proc $arguments $defargCount
}
IDE::System proc invokeTclProcWithArg {proc arg {defargumentsCount 0}} {
    if {$arg==""} {
        set r [$proc]
    } else {
        while 1 {
            set ret [IDE::IDialogEntry getValueWithCancel "$proc\ngive the parameter list\n$arg"]
            if {$ret=="_cancel"} return
            if {[lindex $arg end]=="args" && [llength $ret]>=[llength $arg]-1-$defargumentsCount} break
            if {[llength $ret]<=[llength $arg] && [llength $ret]>=[llength $arg]-$defargumentsCount} break
            IDE::Dialog message {Wrong length of param list}
        }
        set r [namespace eval :: $proc $ret]
    }
    if {$r==""} {
        IDE::Dialog message "empty result from $proc \n args :[string range $r 0 30]"
    } else {
        my inspectString $r
    }
}
IDE::System proc isDatabase {} {
    my instvar isDatabase
    if {[info exists isDatabase]} {
        return 1
    } else {
        return 0
    }
}
IDE::System proc isIgnoreIDEComponents {} {
    my set ignoreIDE
}
IDE::System proc isTkNeverThan84 {} {
    global tk_version
    expr {$tk_version>=8.4}
}
IDE::System proc isWindowsPlatform {} {
    global tcl_platform
    expr {$tcl_platform(platform)=="windows"}
}
IDE::System proc loadExtras extra {
    if {$extra=="sqlDebuger"} {
        if {[IDE::SystemConfigMap loadComponentFromAny xdobry::sqlDebug]} {
            SqlDebugger debug
        }
    } elseif {$extra=="Configuration"} {
        if {[IDE::SystemConfigMap loadComponentFromAny IDEConfiguration]} {
            IDE::ConfigmapBrowser newBrowser
        }
    } elseif {$extra=="ExtendedDebugger"} {
        IDE::SystemConfigMap loadComponentFromAny IDEExtendedDebugger
        IDE::ExtendedDebugger initializeDebugger
        IDE::Dialog message "Please restart your code browsers to get breakpoint support and extended System menu"
    } else {
        IDE::Dialog error "$extra is unknown"
    }
}
IDE::System proc openHTMLBrowser url {
    # Taken from WIKI Page 557
    global tcl_platform

    # It *is* generally a mistake to switch on $tcl_platform(os), particularly
    # in comparison to $tcl_platform(platform).  For now, let's just regard it
    # as a stylistic variation subject to debate.
    switch $tcl_platform(os) {
        Darwin {
            set command [list open $url]
        }
        HP-UX -
        Linux  -
        SunOS {
            foreach executable {mozilla netscape iexplorer opera lynx
                w3m links galeon konquerer mosaic firefox amaya
                browsex elinks} {
                set executable [auto_execok $executable]
                if [string length $executable] {
                    # Do you want to mess with -remote?  How about other browsers?
                    set command [list $executable $url &]
                    break
                }
            }
        }
        {Windows 95} -
        {Windows NT} {
            set command "[auto_execok start] {} [list $url]"
        }
    }
    if [info exists command] {
        if [catch {eval exec $command} err] {
            tk_messageBox -icon error -message "error '$err' with '$command'"
        }
    } else {
        tk_messageBox -icon error -message  "Please ($tcl_platform(os), $tcl_platform(platform)) is not yet ready for browsing."
    }
}
IDE::System proc refreshComponentView component {
    if {[Object isobject IDE::CompViewDB]} {
        set nclass IDE::CompViewDB
    } else {
        set nclass IDE::CompView
    }
    foreach obj [$nclass info instances] {
        $obj refreshComponentView $component
    }
}
IDE::System proc resetMenuStruct {} {
    set mobj [self]::ms
    if {[Object isobject $mobj]} {
        $mobj destroy
        my getMenuStruct
    }
}
IDE::System proc showBusyWhile script {
    update idletasks
    set win [focus]
    if {$win!=""} {
        set win [winfo toplevel $win]
    }
    if {$win==""} {
        set win .
    }
    set alt [$win cget -cursor]
    $win configure -cursor clock
    uplevel $script
    $win configure -cursor $alt
}
IDE::System proc showFreshMethods {} {
    set list [ide::lcollect each [IDE::MethodDescription getFreshInserted] {
        $each printStringShort}]
    if {[llength $list]==0} {
        IDE::Dialog message "No fresh-inserted methods"
    }
    IDE::MethodBrowser newBrowserList $list fresh-inserted
}
IDE::System proc signalComponentsChanged {} {
    if {[Object isobject IDE::CompViewDB]} {
        set nclass IDE::CompViewDB
    } else {
        set nclass IDE::CompView
    }
    foreach obj [$nclass info instances] {
        $obj showComponents
    }
}
IDE::System proc substituteString string {
    namespace eval :: subst [list $string]
}
IDE::System proc tryBrowseAsObjectList string {
    if {![info complete $string]} {return 0}
    if {[catch {set len [llength $string]}]} {return 0}
    if {[llength $string]==1} {return 0}
    foreach obj $string {
        if {![Object isobject $obj]} {
            return 0
        }
    }
    IDE::ObjectBrowser browseObjectsList $string
    return 1
}
IDE::System proc unknown args {
    error "Unknow [self] $args"
}
@ IDE::System proc versionAllCoreComponents {} {
    description {IDE::SystemConfigMap loadComponentsFromList [IDE::SystemConfigMap getCleanedLoadList [concat [my getExtraComponents] [my getCoreComponents]]]}
}
IDE::System proc versionAllCoreComponents {{versionInfo {}}} {
    foreach cname [concat [my getExtraComponents] [my getCoreComponents]] {
        set cobj [IDE::Component getCompObjectForNameIfExist $cname]
        if {$cobj!="" && [$cobj isPersistent] && ![$cobj isclosed]} {
            if {$versionInfo!=""} {
                $cobj setVersionInfo $versionInfo
            }
            $cobj versionEdition
        }
    }
}
IDE::System initializeAfterLoad

